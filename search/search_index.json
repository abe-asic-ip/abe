{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#abe-a-better-environment-for-open-source-asic-ip-development","title":"ABE: A Better Environment for Open-Source ASIC IP Development","text":"<p>ABE (\"A Better Environment\") is a lightweight, modern environment for open-source ASIC IP development. It combines microarchitecture tools, reusable RTL designs, synthesis, formal verification, and Python-based design verification (DV). ABE runs on free and open-source tools.</p> <p>The goal is simple: make block-level ASIC development easier, clearer, and more productive for professional engineers, students, researchers, and enthusiasts.</p> <p>See the git repository</p> <p>Welcome to ABE \u2014 a better environment for open-source ASIC IP development.</p>"},{"location":"#what-is-abe","title":"What is ABE?","text":"<p>ABE provides tools and resources for digital design and verification:</p> <ul> <li>Microarchitecture tools: Including fifo-depth, a CP-SAT (Constraint Programming - Satisfiability)-based tool that computes provably minimal FIFO depths and flow-control parameters for complex traffic profiles.</li> <li>UVM-based Python verification environment: A complete design verification (DV) methodology using cocotb and pyuvm.</li> <li>Developer workflow and tooling: Make-based workflows, synthesis scripts, and code management tools.</li> <li>Reusable ASIC Designs (RAD): A library of RTL designs validated with ABE's synthesis, formal verification, and DV flows.</li> </ul> <p>These components work together to support the full development cycle from microarchitecture to verification.</p>"},{"location":"#who-is-abe-for","title":"Who is ABE for?","text":"<p>ABE is designed for anyone who wants to build ASIC modules with a modern, open-source workflow:</p> <ul> <li>Professional engineers who prefer Python for modeling and verification</li> <li>Professional engineers who want license-free tools</li> <li>Students learning microarchitecture, design, formal, or verification</li> <li>Researchers building prototypes and publishing reproducible results</li> <li>Enthusiasts exploring ASIC IP development with free tools</li> </ul> <p>ABE works well if you want a workflow that is clear, repeatable, and Python-friendly.</p>"},{"location":"#why-was-abe-created","title":"Why was ABE created?","text":"<p>ASIC IP development often involves creating microarchitecture tools, scripts, and testbenches for each new project. ABE's philosophy is practical: provide solid, reusable infrastructure so designers can focus on building designs rather than recreating validation frameworks.</p> <p>ABE was created to address these common challenges:</p> <ul> <li>Analytical FIFO sizing. ABE provides fifo-depth, a CP-SAT-based analytical tool that complements simulation and spreadsheet approaches by computing provably minimal FIFO depths and flow-control parameters for complex, multi-layered traffic profiles across various flow-control protocols.</li> <li>Comprehensive DV infrastructure. Many open-source projects provide RTL. ABE adds complete Python-based verification environments with agents, scoreboards, reference models, functional coverage, and randomization.</li> <li>Python modeling and RTL simulation are often separate. ABE connects them using cocotb, pyuvm, and Python reference models.</li> <li>Workflow and structure around open-source tools. ABE provides Makefiles, directory conventions, naming patterns, and tooling to complement powerful open-source simulators with consistent project organization.</li> </ul>"},{"location":"#where-does-abe-fit-in-the-open-source-ecosystem","title":"Where does ABE fit in the open-source ecosystem?","text":"<p>ABE sits between lightweight code-writing tools and complete SoC frameworks. ABE is designed to work together with other open-source projects and complement existing workflows.</p>"},{"location":"#abe-and-eda-playgrounds-ai-copilots","title":"ABE and EDA playgrounds / AI copilots","text":"<p>These tools are excellent for writing SystemVerilog code and interactive experimentation. ABE complements them by providing infrastructure for complete, reusable ASIC IP development with synthesis, formal verification, Python-based DV, and structured workflows.</p>"},{"location":"#abe-and-svunit-vunit","title":"ABE and SVUnit / VUnit","text":"<p>These are excellent testing frameworks for VHDL/SystemVerilog. SVUnit focuses on unit testing, while VUnit provides verification components and block-level testing in VHDL/SystemVerilog. ABE complements them by providing Python-based verification (cocotb + pyuvm) with reusable agents, scoreboards, reference models, and functional coverage.</p>"},{"location":"#abe-and-verilators-new-uvm-support","title":"ABE and Verilator's new UVM support","text":"<p>Verilator now supports UVM. This is great progress for open-source SystemVerilog verification. ABE offers a different approach with Python-based UVM (cocotb + pyuvm). This provides easier integration with Python reference models, Python workflows, and Python ecosystem tools (e.g. data analysis).</p>"},{"location":"#abe-and-opentitan","title":"ABE and OpenTitan","text":"<p>OpenTitan is an open-source silicon Root of Trust project. It provides a complete SoC design, reusable ASIC IP, and production-grade SystemVerilog UVM verification. ABE has a different scope, focusing on general-purpose ASIC blocks with microarchitecture tools and Python-based verification for ASIC IP development.</p>"},{"location":"#how-can-i-get-started","title":"How Can I Get Started?","text":"<ol> <li>Clone the repository</li> <li>Set up the Python environment (see details)</li> <li>Try fifo-depth on an example YAML spec to see CP-SAT based FIFO optimization in action</li> <li>Install free tools: see RAD Design, RAD Formal, and RAD DV for details.</li> <li>Explore a RAD design to experience RTL, synthesis, formal, and DV flows firsthand</li> <li>Run a test with <code>dv</code> and a (cocotb + pyuvm) bench</li> </ol>"},{"location":"#the-abe-toolkit","title":"The ABE Toolkit","text":"<p>ABE provides three main categories of tools and resources:</p>"},{"location":"#microarchitecture-tools","title":"Microarchitecture Tools","text":"<p>ABE's microarchitecture tools help you make informed decisions before writing RTL.</p>"},{"location":"#fifo-depth-tool","title":"FIFO Depth Tool","text":"<p>The fifo-depth tool is a CP-SAT-based optimization tool that addresses an important challenge in ASIC microarchitecture: determining the minimal FIFO depth and flow-control parameters required to prevent underflow or overflow under complex traffic conditions.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>The fifo-depth tool offers several advantages through its CP-SAT-based approach:</p> <ul> <li>Provably minimal: Uses CP-SAT optimization to find the smallest FIFO depth that satisfies all constraints, and computes appropriate flow-control parameters (such as thresholds for XON/XOFF or credits for CBFC) when applicable.</li> <li>Complex traffic profiles: Handles layered, hierarchical traffic specifications (cycle, transaction, burst, stream levels) that are difficult to analyze manually.</li> <li>Multiple flow-control protocols: Supports Ready/Valid, XON/XOFF, Credit-Based Flow Control (CBFC), and replay buffers.</li> <li>CDC optimization: For multi-clock FIFOs, proposes optimal partitioning between asynchronous and synchronous storage.</li> <li>Witness sequences: Generates the exact read/write patterns that cause the worst-case occupancy.</li> </ul> <p>This analytical approach complements spreadsheet and simulation-based methods and can help identify corner cases and optimize FIFO provisioning in complex scenarios.</p>"},{"location":"#packet-quantization-calculator","title":"Packet Quantization Calculator","text":"<p>The pkt-quantize tool calculates bandwidth and packet rate metrics for packet-based interfaces where packets are quantized to bus beats.</p>"},{"location":"#developer-tooling","title":"Developer Tooling","text":"<p>ABE includes:</p> <ul> <li>Standard directory layout</li> <li>Python environment setup</li> <li>Python static analysis with isort, black, pylint, and mypy</li> <li>Make targets for RTL development, synthesis, formal, and DV</li> <li>Documentation conventions</li> </ul> <p>All designed to help you build ASIC IP quickly and consistently.</p>"},{"location":"#reusable-asic-designs-rad","title":"Reusable ASIC Designs (RAD)","text":"<p>RAD provides production-quality RTL designs that have been validated using ABE's synthesis, formal verification, and DV flows.</p> <p>Each RAD design includes:</p> <ul> <li>RTL implementation</li> <li>Synthesis</li> <li>Formal verification and coverage</li> <li>A Python reference model</li> <li>A complete DV environment with agents, scoreboards, functional coverage, and randomization</li> <li>Documentation</li> </ul> <p>Current RAD designs include core CDC building blocks: synchronizers, Multi-Cycle Path formulations, and asynchronous FIFOs.</p>"},{"location":"#explore-abe","title":"Explore ABE","text":"<p>Ready to dive deeper? Here's your map to everything ABE has to offer:</p> Document Description FIFO Depth Tool CP-SAT based tool for computing minimal FIFO depths and flow-control parameters Packet Quantization Calculator Packet quantization calculator for performance metrics and bus analysis ABE Python Development Python development environment setup and tooling RAD Design RAD design support for RTL quality, linting, and synthesis RAD Formal RAD formal verification flow and methodology RAD DV RAD design verification using cocotb and pyuvm Creating a New RAD Design Guide for creating new RAD designs"},{"location":"#faq","title":"FAQ","text":""},{"location":"#is-abe-good-for-beginners","title":"Is ABE good for beginners?","text":"<p>Yes. ABE was designed to be clear and easy to learn. It is friendly to people who are new to ASIC IP development.</p>"},{"location":"#is-abe-an-soc-framework","title":"Is ABE an SoC framework?","text":"<p>ABE focuses on microarchitecture analysis, reusable ASIC IP, and DV patterns rather than full SoC integration.</p>"},{"location":"#does-abe-replace-uvm","title":"Does ABE replace UVM?","text":"<p>ABE uses pyuvm, a Python implementation of UVM. Some users may prefer Python UVM. Others may prefer SystemVerilog UVM. Both approaches have advantages and disadvantages.</p>"},{"location":"#can-i-use-abe-with-commercial-simulators","title":"Can I use ABE with commercial simulators?","text":"<p>ABE currently supports Verilator and Icarus Verilog. While cocotb works with commercial simulators, ABE's test infrastructure would need updates to support them. Contributors with simulator access can extend the <code>dv</code> tool and submit changes to the repository.</p>"},{"location":"#is-the-fifo-depth-tool-a-simulator","title":"Is the fifo-depth tool a simulator?","text":"<p>No. It is an analytical tool that uses deterministic traffic analysis and a CP\u2011SAT solver to determine worst\u2011case depths and flow-control parameters.</p>"},{"location":"#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"design/","title":"RAD Design","text":""},{"location":"design/#reusable-asic-designs-rad-design","title":"Reusable ASIC Designs (RAD) \u2013 Design","text":""},{"location":"design/#overview","title":"Overview","text":"<p>The Reusable ASIC Designs (RAD) environment provides a consistent, high\u2011quality foundation for building reusable SystemVerilog IP within the ABE project. RAD focuses on RTL quality. RAD helps designs achieve:</p> <ul> <li>Consistency across modules</li> <li>Clean structure for simulation, lint, formal, and synthesis</li> <li>Compatibility with open\u2011source tools</li> <li>Readiness for verification</li> </ul> <p>This document describes the design workflow. It covers what happens after writing RTL and before formal verification and DV.</p>"},{"location":"design/#audience","title":"Audience","text":"<ul> <li>ASIC architects and RTL designers producing reusable IP</li> </ul>"},{"location":"design/#purpose","title":"Purpose","text":"<ul> <li>Establish consistent design conventions</li> <li>Ensure RTL correctness before formal verification or DV</li> <li>Provide standard flows for formatting, linting, and synthesis</li> <li>Speed up adding new designs to the RAD library</li> </ul>"},{"location":"design/#key-features","title":"Key Features","text":"<ul> <li>Unified Make targets for RTL formatting, linting, and synthesis</li> <li>Verible\u2011based SystemVerilog formatting and linting</li> <li>Verilator\u2011based SystemVerilog linting</li> <li>Yosys\u2011based synthesis flow (via sv2v)</li> <li>Standardized directory structure and naming</li> <li>Reusable shared components under <code>rad/shared</code></li> </ul>"},{"location":"design/#getting-started","title":"Getting Started","text":""},{"location":"design/#set-up-and-install-the-environment","title":"Set Up and Install the Environment","text":"<p>See ABE Python Development for Python environment setup details.</p> <pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"design/#install-required-tools","title":"Install Required Tools","text":"<p>Run:</p> <pre><code>make deps-design\n</code></pre> <p>This prints any missing host\u2011side tools. Installation is platform\u2011specific and outside the scope of this document.</p>"},{"location":"design/#run-examples","title":"Run Examples","text":"<pre><code>make DESIGN=rad_async_fifo rtl-format\nmake DESIGN=rad_async_fifo rtl-lint-verible\nmake DESIGN=rad_async_fifo rtl-lint-verilator\nmake DESIGN=rad_async_fifo synth\nmake DESIGN=rad_async_fifo synth-report\n</code></pre>"},{"location":"design/#examine-outputs","title":"Examine Outputs","text":"<ul> <li><code>rtl-*</code> targets print to the console</li> <li><code>synth</code> writes results to <code>out_synth/&lt;design&gt;/</code></li> </ul>"},{"location":"design/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>.\n\u251c\u2500\u2500 mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00-vars.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10-helpers.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 20-python.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 30-rtl.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 40-synth.mk\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 rad\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_mem.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_rptr.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_sync.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_wptr.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 srclist.f\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 shared\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_pulse_gen.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rad_timescale.svh\n\u251c\u2500\u2500 Makefile\n</code></pre>"},{"location":"design/#makefiles","title":"Makefiles","text":"<p>Makefiles are in directory <code>mk</code></p> <ul> <li>Common flags come from <code>00-vars.mk</code>.</li> <li>RTL commands are in <code>30-rtl.mk</code>.</li> <li>Synthesis commands are in <code>40-synth.mk</code>.</li> </ul> <p>Common commands:</p> <pre><code>make rtl-help\nmake synth-help\n</code></pre>"},{"location":"design/#guidelines-for-creating-new-rad-rtl-designs","title":"Guidelines for Creating New RAD RTL Designs","text":"<p>These guidelines help maintain consistency and tooling compatibility across the RAD library:</p>"},{"location":"design/#directory-structure","title":"Directory Structure","text":"<p>Create designs under:</p> <pre><code>src/abe/rad/rad_&lt;design&gt;/rtl/\n</code></pre> <p>Example:</p> <pre><code>src/abe/rad/rad_async_fifo/rtl/\n</code></pre>"},{"location":"design/#file-naming","title":"File Naming","text":"<p>RTL filenames should begin with:</p> <pre><code>rad_&lt;design&gt;*\n</code></pre> <p>This naming pattern helps tools find files automatically and keeps designs organized.</p>"},{"location":"design/#source-list-file","title":"Source List File","text":"<p>Each design includes:</p> <pre><code>src/abe/rad/rad_&lt;design&gt;/rtl/srclist.f\n</code></pre> <p>This file lists:</p> <ul> <li>SystemVerilog source files</li> <li>Include directories</li> <li>Compile-time defines</li> </ul> <p>Every tool (Verilator, Verible, sv2v, Yosys, DV) uses the same <code>srclist.f</code>.</p>"},{"location":"design/#timescale-and-shared-headers","title":"Timescale And Shared Headers","text":"<p>RTL should include the shared timescale:</p> <pre><code>`include \"rad_timescale.svh\"\n</code></pre> <p>Consider using reusable components from:</p> <pre><code>src/abe/rad/shared/rtl\n</code></pre> <p>This avoids reimplementing utilities such as:</p> <ul> <li>Pulse generators</li> <li>Synchronizers</li> <li>Common CDC helpers</li> </ul>"},{"location":"design/#clock-and-reset-naming","title":"Clock and Reset Naming","text":"<p>For designs with a single clock and reset:</p> <ul> <li>Name the clock <code>clk</code></li> <li>Use an active-low reset named <code>rst_n</code></li> </ul> <p>The DV base classes assume these names, minimizing verification effort. This convention also maintains consistency across all RAD IP.</p>"},{"location":"design/#reference-design","title":"Reference Design","text":"<p><code>rad_async_fifo</code> is a complete example. It shows the recommended directory structure, conventions, and Make integration.</p>"},{"location":"design/#static-rtl-tools","title":"Static RTL Tools","text":""},{"location":"design/#rtl-formatting-with-verible","title":"RTL Formatting With Verible","text":"<p>Formatting makes code uniform and easy to read.</p> <ul> <li>Uses Verible</li> <li>Configured in <code>.verible-format</code></li> </ul> <p>Run:</p> <pre><code>make DESIGN=&lt;design&gt; rtl-format\n</code></pre>"},{"location":"design/#rtl-linting-with-verible","title":"RTL Linting With Verible","text":"<p>Verible catches:</p> <ul> <li>Style and naming issues</li> <li>Structural problems</li> <li>Common SystemVerilog pitfalls</li> </ul> <p>Run:</p> <pre><code>make DESIGN=&lt;design&gt; rtl-lint-verible\n</code></pre>"},{"location":"design/#rtl-linting-with-verilator","title":"RTL Linting With Verilator","text":"<p>Verilator checks for deeper issues:</p> <ul> <li>Type mismatches</li> <li>Unsupported constructs</li> <li>Missing signals</li> <li>Simulation readiness</li> </ul> <p>Run:</p> <pre><code>make DESIGN=&lt;design&gt; rtl-lint-verilator\n</code></pre> <p>Verilator linting is important because RAD DV uses Verilator as the default simulator.</p>"},{"location":"design/#synthesis-flow","title":"Synthesis Flow","text":"<p>Yosys synthesis checks that designs can be synthesized and provides statistics.</p>"},{"location":"design/#endtoend-flow","title":"End\u2011to\u2011End Flow","text":"<ol> <li>sv2v converts SystemVerilog \u2192 Verilog</li> <li>Yosys synthesizes the Verilog</li> <li>Reports are written to:</li> </ol> <pre><code>out_synth/&lt;design&gt;/\n</code></pre>"},{"location":"design/#invoke-synthesis","title":"Invoke Synthesis","text":"<pre><code>make DESIGN=&lt;design&gt; synth\n</code></pre>"},{"location":"design/#examine-synthesis-outputs","title":"Examine Synthesis Outputs","text":"File Description <code>&lt;design&gt;.v</code> sv2v converted Verilog <code>&lt;design&gt;_net.v</code> Gate-level netlist <code>&lt;design&gt;_net.json</code> Structural JSON netlist <code>stat_width.txt</code> Wire/port/cell counts <code>yosys.log</code> Full synthesis log"},{"location":"design/#view-statistics","title":"View Statistics","text":"<pre><code>make DESIGN=&lt;design&gt; synth-report\n</code></pre>"},{"location":"design/#graph-visualization","title":"Graph Visualization","text":"<pre><code>make DESIGN=&lt;design&gt; synth-dot\n</code></pre> <p>Creates:</p> <pre><code>out_synth/&lt;design&gt;/&lt;design&gt;.dot\n</code></pre> <p>This graph helps you understand how modules connect.</p>"},{"location":"design/#faq","title":"FAQ","text":""},{"location":"design/#should-i-run-verible-before-checking-in-rtl","title":"Should I run Verible before checking in RTL?","text":"<p>Yes. RAD uses consistent formatting across all designs. Run:</p> <pre><code>make DESIGN=&lt;design&gt; rtl-format\n</code></pre> <p>See RTL Formatting for details.</p>"},{"location":"design/#why-does-verilator-catch-errors-that-verible-misses","title":"Why does Verilator catch errors that Verible misses?","text":"<p>Verilator checks meaning (like a compiler). Verible checks structure and style. They work together to find different types of errors.</p> <p>See RTL Linting \u2013 Verible and RTL Linting \u2013 Verilator for details.</p>"},{"location":"design/#should-every-rad-design-go-through-synthesis","title":"Should every RAD design go through synthesis?","text":"<p>Yes. Running synthesis early has several benefits:</p> <ul> <li>Verifies the design can be synthesized</li> <li>Catches issues linters may miss</li> <li>Helps avoid problems later in formal verification or DV</li> </ul> <p>See Synthesis Flow for details.</p>"},{"location":"design/#why-does-synthesis-use-sv2v","title":"Why does synthesis use sv2v?","text":"<p>Yosys provides excellent Verilog support. <code>sv2v</code> enables consistent conversion from SystemVerilog to Verilog, allowing us to use Yosys effectively.</p> <p>See End\u2011to\u2011End Flow for details.</p>"},{"location":"design/#what-if-my-module-needs-vendor-specific-cells","title":"What if my module needs vendor-specific cells?","text":"<p>Wrap vendor cells in SystemVerilog wrappers. This keeps the RAD synthesis flow open\u2011source and portable.</p>"},{"location":"design/#can-i-add-custom-lint-rules","title":"Can I add custom lint rules?","text":"<p>Yes. Edit:</p> <ul> <li><code>.rules.verible_lint</code> for Verible</li> <li><code>00-vars.mk</code> for Verilator flags</li> </ul>"},{"location":"design/#why-separate-design-formal-and-dv-directories","title":"Why separate design, formal, and DV directories?","text":"<p>Separate directories provide:</p> <ul> <li>Independent Make flows</li> <li>Reproducible builds</li> <li>Clean organization</li> </ul> <p>See RAD Formal and RAD DV for details on those flows.</p>"},{"location":"design/#references","title":"References","text":"<ul> <li>Verible</li> <li>Verilator</li> <li>Yosys</li> <li>sv2v</li> </ul>"},{"location":"design/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"dv/","title":"RAD DV","text":""},{"location":"dv/#reusable-asic-designs-rad-design-verification-dv","title":"Reusable ASIC Designs (RAD) \u2013 Design Verification (DV)","text":""},{"location":"dv/#overview","title":"Overview","text":"<p>The Reusable ASIC Designs (RAD) DV environment provides a complete, reusable, and open\u2011source verification framework for all RAD designs. It combines cocotb, pyuvm, and a robust set of shared base classes, enabling UVM\u2011style verification using modern Python tooling.</p> <p>RAD DV follows the ABE philosophy:</p> <ul> <li>Consistency: All RAD designs use the same structure and DV   architecture</li> <li>Reusability: Shared base classes for agents, drivers, monitors,   sequences, scoreboards, and coverage</li> <li>Automation: Make targets, regression scripts, auto\u2011generated benches</li> <li>Portability: 100% open\u2011source toolchain   (cocotb, Verilator,   pyuvm,   pytest)</li> </ul> <p>RAD Design ensures RTL quality, RAD Formal ensures logical correctness, and RAD DV ensures functional correctness under realistic stimulus.</p>"},{"location":"dv/#audience","title":"Audience","text":"<ul> <li>DV engineers building verification environments for new RAD designs</li> <li>RTL designers writing tests or debugging failures</li> <li>Contributors adding new modules to the RAD library</li> </ul>"},{"location":"dv/#purpose","title":"Purpose","text":"<ul> <li>Establish consistent DV architecture across all RAD designs</li> <li>Explain the shared DV infrastructure, tools, and base classes</li> <li>Show how to create a new RAD DV bench</li> <li>Document how to run, debug, and extend RAD testbenches</li> </ul>"},{"location":"dv/#key-features","title":"Key Features","text":"<ul> <li>UVM\u2011style architecture built on cocotb + pyuvm</li> <li>Reusable base class library (agent/driver/monitor/env/sb/coverage)</li> <li>Automated regression tools</li> <li>Built\u2011in support for multi\u2011clock, multi\u2011agent designs</li> <li>Bench template generator (<code>dv-make-bench</code>)</li> <li>YAML\u2011driven regressions (<code>dv-regress</code>)</li> <li>Unified Makefile integration (<code>make dv</code>, <code>make dv-regress</code>)</li> </ul>"},{"location":"dv/#getting-started","title":"Getting Started","text":""},{"location":"dv/#set-up-and-install-the-environment","title":"Set Up and Install the Environment","text":"<p>See ABE Python Development for Python environment setup details.</p> <pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"dv/#install-required-tools","title":"Install Required Tools","text":"<p>Install Verilator and a waveform viewer such as Surfer or GTKWave.</p>"},{"location":"dv/#run-examples","title":"Run Examples","text":"<p>A single test:</p> <pre><code>dv --design=rad_async_fifo --test=test_rad_async_fifo --waves 1\n</code></pre> <p>A regression:</p> <pre><code>make DESIGN=rad_cdc_sync dv-regress-design\n</code></pre> <p>All regressions in the repo:</p> <pre><code>make dv-regress-all-and-report\n</code></pre>"},{"location":"dv/#examine-outputs","title":"Examine Outputs","text":"<pre><code>out_dv/builds/&lt;rad_design&gt;.&lt;hash&gt;/\nout_dv/tests/&lt;rad_design&gt;.&lt;hash&gt;.&lt;test&gt;.&lt;seed&gt;\n</code></pre>"},{"location":"dv/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>.\n\u251c\u2500\u2500 mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00-vars.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10-helpers.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 20-python.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 60-dv.mk\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 rad\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_regress.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_coverage.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_driver.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_env.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_item.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_monitor_in.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_monitor_out.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_ref_model.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_reset_sink.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_sb.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_sequence.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test_rad_async_fifo.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_template\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 dv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_coverage.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_driver.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_item.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_monitor_in.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_monitor_out.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_ref_model.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 template_sequence.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 test_template.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 shared\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_agent.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_clock_driver.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_clock_mixin.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_coverage.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_driver.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_env.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_item.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_monitor_in.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_monitor_out.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_monitor.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_ref_model.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_reset_driver.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_reset_item.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_reset_monitor.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_reset_sink.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_sb_comparator.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_sb_predictor.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_sb.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_sequence.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_sequencer.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 base_test.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 utils_cli.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils_dv.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 tools\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_make_bench.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_regress_all.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_regress.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_report.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 flatten_srclist.sh\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 Makefile\n</code></pre>"},{"location":"dv/#methodology","title":"Methodology","text":""},{"location":"dv/#choices","title":"Choices","text":""},{"location":"dv/#methodology-uvm-for-block-level-verification","title":"Methodology: UVM for Block-Level Verification","text":"<p>UVM provides a proven, standardized methodology that is good for block-level verification. Cliff Cummings' uvmtb_template paper (see Literature section) shows how UVM works well for block-level testbenches.</p>"},{"location":"dv/#technology-cocotbpyuvm-over-verilatorsystemverilog-uvm","title":"Technology: cocotb/pyuvm over Verilator/SystemVerilog UVM","text":"<p>ABE's open-source mission uses an open-source simulator. When the project began, Verilator did not support UVM for SystemVerilog (it does now). This made cocotb/pyuvm a natural choice for combining UVM methodology with open-source simulation.</p>"},{"location":"dv/#discipline-uvm-standard-patterns-over-python-idioms","title":"Discipline: UVM Standard Patterns over Python Idioms","text":"<p>Python enables design patterns not possible in SystemVerilog. Standard UVM does not support these patterns. However, RAD DV uses fewer Python-specific patterns. This keeps UVM portable and easier to read for engineers who know SystemVerilog UVM. Exception: small mixins for clock/reset infrastructure reduce repetitive code without hiding the UVM structure.</p>"},{"location":"dv/#benefits","title":"Benefits","text":""},{"location":"dv/#python-reference-models","title":"Python Reference Models","text":"<p>Traditional UVM testbenches implement reference models in SystemVerilog or C++ (via DPI-C). Using Python with SystemVerilog simulators is very difficult. This creates several challenges:</p> <ul> <li>The translation gap: ASIC architects often develop specifications and   models in Python. Verification engineers must rewrite them in   SystemVerilog or C++ for use in UVM scoreboards</li> <li>Maintenance creates errors: Keeping reference models synchronized with   changing Python specifications causes translation errors and extra   maintenance work</li> <li>Missed reuse opportunities: Python's powerful features and extensive   libraries (NumPy, SciPy, etc.) cannot be used for behavioral modeling in   traditional UVM</li> </ul> <p>RAD DV solves these problems by allowing reference models to be written directly in Python with the testbench:</p> <ul> <li>Architects' Python specifications can often be used directly as reference   models with small changes</li> <li>Model mismatches are greatly reduced because there is no translation   layer</li> <li>Debug time can decrease\u2014the Wilson Research Group Functional Verification   Study reports that debugging is a significant portion of verification   effort</li> </ul>"},{"location":"dv/#rich-python-ecosystem","title":"Rich Python Ecosystem","text":"<p>Open-source simulators like Verilator and Icarus Verilog provide basic simulation capabilities. They do not have the integrated test management, analysis, and debugging tools found in commercial products. Python's ecosystem fills this gap and gives open-source developers access to similar capabilities:</p> <ul> <li>Test management: pytest for test   discovery, parametrization, fixtures, and regression orchestration</li> <li>Data analysis: NumPy, pandas for processing results, analyzing   coverage trends, and generating metrics</li> <li>Visualization: Matplotlib, seaborn for plotting coverage data,   regression trends, and performance metrics</li> <li>Debugging and introspection: Interactive debugging and comprehensive   logging for development and debug workflows</li> <li>Automation and CI/CD: Direct integration with git, reporting tools,   and continuous integration pipelines</li> </ul>"},{"location":"dv/#known-limitations","title":"Known Limitations","text":"<ul> <li>Simulator support: Only Verilator and   Icarus Verilog are currently   supported. While cocotb supports many   commercial simulators (VCS, Questa, Xcelium, etc.), integration into RAD   DV requires access to licenses for testing and validation.</li> <li>Sequential test execution: Regression tests run one at a time instead   of in parallel. This makes large test suites run slower</li> <li>Third-party VIP integration: Does not integrate with commercial VIP   or third-party AIP</li> </ul>"},{"location":"dv/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Additional simulator support: Expand beyond   Verilator and   Icarus Verilog</li> <li>Parallel test execution: Enable concurrent test runs for faster   regression completion</li> <li>Multi-agent single-clock example: Example bench demonstrating single   clock/reset domain with multiple agents (multiple interfaces)</li> <li>Code coverage integration: Example using   Verilator's coverage capabilities</li> <li>Constrained randomization: Example using   cocotb-coverage for   constraint-based stimulus generation</li> <li>Functional coverage workflows: Examples demonstrating coverage   database merging, cross-coverage, and coverage-driven verification</li> <li>Standard protocol libraries: Pre-built reusable agents for common bus   protocols (AXI, APB, AHB, etc.)</li> </ul>"},{"location":"dv/#makefiles","title":"Makefiles","text":"<p>Makefiles are in directory <code>mk</code></p> <ul> <li>Common flags come from <code>00-vars.mk</code>.</li> <li>Python commands are in <code>20-python.mk</code>.</li> <li>DV commands are in <code>mk/60-dv.mk</code>.</li> </ul> <p>Common commands:</p> <pre><code>make py-help\nmake dv-help\n</code></pre>"},{"location":"dv/#rad-dv-architecture","title":"RAD DV Architecture","text":"<p>Located under:</p> <pre><code>src/abe/rad/shared/dv/\n</code></pre> <p>RAD DV environments use classic UVM patterns implemented in Python via pyuvm and cocotb. All testbenches inherit from reusable base classes that provide standard verification infrastructure.</p> <p>The following table summarizes the shared base classes. See the module docstrings for detailed usage.</p> File Description <code>base_agent.py</code> UVM agent connecting sequencer, driver, and separate input/output monitors <code>base_clock_driver.py</code> Clock generation component with configurable period, phase, and startup delay <code>base_clock_mixin.py</code> Shared clock configuration, signal binding, and drive edge alignment utilities <code>base_coverage.py</code> Functional coverage subscriber integrating cocotb-coverage with pyuvm <code>base_driver.py</code> UVM driver with clock synchronization, reset handling, and BFM hooks <code>base_env.py</code> Top-level environment creating agents, coverage, scoreboard, and reset infrastructure <code>base_item.py</code> Transaction item with input/output field separation, cloning, and comparison <code>base_monitor.py</code> Base monitor with clock synchronization and analysis port infrastructure <code>base_monitor_in.py</code> Design input monitor sampling at rising edge using ReadOnly trigger <code>base_monitor_out.py</code> Design output monitor sampling in read-only phase before next active edge <code>base_ref_model.py</code> Reference model computing expected design behavior from input transactions <code>base_reset_driver.py</code> Reset generation with configurable polarity, duration, and settling time <code>base_reset_item.py</code> Reset transaction capturing raw signal level and polarity-resolved state <code>base_reset_monitor.py</code> Reset monitor publishing transactions on reset signal changes <code>base_reset_sink.py</code> Subscriber forwarding reset events to driver and predictor components <code>base_sb.py</code> Top-level scoreboard managing predictor and comparator components <code>base_sb_comparator.py</code> Dual-FIFO comparator for expected vs actual transaction checking <code>base_sb_predictor.py</code> Predictor generating expected transactions using reference model <code>base_sequence.py</code> Item-generating sequence with factory support and customization hooks <code>base_sequencer.py</code> Standard UVM sequencer managing sequence scheduling and driver connection <code>base_test.py</code> Base test with configuration management, factory overrides, and phase execution <code>utils_cli.py</code> CLI utilities for reading environment variables, plusargs, and factory overrides <code>utils_dv.py</code> Type-safe config_db wrappers, signal handle utilities, and logger configuration"},{"location":"dv/#structure-of-a-rad-dv-bench","title":"Structure of a RAD DV Bench","text":"<p>Core files required in every bench:</p> <pre><code>rad_&lt;design&gt;/dv/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 dv_regress.yaml\n\u251c\u2500\u2500 rad_&lt;design&gt;_coverage.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_driver.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_item.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_monitor_in.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_monitor_out.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_ref_model.py\n\u251c\u2500\u2500 rad_&lt;design&gt;_sequence.py\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 test_rad_&lt;design&gt;.py\n</code></pre> <p>Additional files for complex designs:</p> <pre><code>rad_&lt;design&gt;/dv/\n\u251c\u2500\u2500 rad_&lt;design&gt;_env.py          # Custom environment (multi-agent, etc.)\n\u251c\u2500\u2500 rad_&lt;design&gt;_reset_sink.py   # Custom reset routing\n\u2514\u2500\u2500 rad_&lt;design&gt;_sb.py           # Custom scoreboard logic\n</code></pre> <p>Note: The test file should have the prefix <code>test_</code> for pytest discovery.</p>"},{"location":"dv/#dv-tools","title":"DV Tools","text":"<p>The RAD DV environment includes five main tools under:</p> <pre><code>src/abe/rad/tools/\n</code></pre> <p>The following sections describe the tools at a high level. See the module docstrings for more detail.</p>"},{"location":"dv/#1-dv-main-front-end-runs-a-single-test","title":"1. <code>dv</code> \u2014 Main Front-End (Runs a Single Test)","text":""},{"location":"dv/#dv-purpose","title":"<code>dv</code> Purpose","text":"<ul> <li>Verify RTL designs using cocotb +   pyuvm +   pytest framework</li> <li>Support multiple simulators (Verilator,   Icarus Verilog) with configurable   waveform generation (FST, VCD)</li> <li>Execute single or multi-seed regression testing with automatic result   tracking</li> <li>Generate test manifests for build/test reproducibility and caching</li> <li>Provide flexible build/test orchestration via <code>--cmd</code> (build-only,   test-only, or both)</li> </ul>"},{"location":"dv/#dv-typical-usage","title":"<code>dv</code> Typical Usage","text":"<pre><code>dv --design=rad_async_fifo --test=test_rad_async_fifo --seed=1999\nmake DESIGN=rad_async_fifo TEST=test_rad_async_fifo DV_OPTS='-seed=123' dv\n</code></pre>"},{"location":"dv/#dv-arguments","title":"<code>dv</code> Arguments","text":"Argument Type Required Default Description <code>--cmd</code> choice No <code>both</code> Run only build, only test, or both (choices: build, test, both) <code>--sim</code> choice No <code>verilator</code> Simulator to use (choices: verilator, icarus) <code>--outdir</code> string No <code>out_dv</code> Output directory for build and test artifacts <code>--verbosity</code> choice No <code>info</code> Logging level for Python/pyuvm/cocotb (choices: critical, error, warning, info, debug, notset) <code>--waves</code> choice No <code>0</code> Enable waveform generation (choices: 0, 1) <code>--waves_fmt</code> choice No <code>fst</code> Waveform format (choices: fst, vcd) <code>--design</code> string Yes - Design to build (e.g., rad_async_fifo) <code>--build-force</code> flag No <code>False</code> Force a rebuild even if build directory exists <code>--build-arg</code> string No - Extra build argument passed verbatim to the simulator (repeatable, e.g., --build-arg=-DSIMULATE_METASTABILITY) <code>--test</code> string Yes* - Test module name in format abe.rad.\\&lt;rad_design&gt;.dv.\\&lt;test_module&gt; (required for test/both commands) <code>--expect</code> choice No <code>PASS</code> Expected test result for reporting (choices: PASS, FAIL) <code>--seeds</code> list No - Explicit seed list (decimal or 0x...). Overrides --nseeds <code>--nseeds</code> int No <code>0</code> Generate N random seeds if --seeds not given <code>--seed-base</code> int No <code>1999</code> Base seed for generating additional seeds <code>--seed-out</code> path No - Write the final seed list to a file (one per line) <code>--check-en</code> choice No <code>1</code> Enable checkers (choices: 0, 1) <code>--coverage-en</code> choice No <code>1</code> Enable coverage collection (choices: 0, 1)"},{"location":"dv/#dv-build-outputs","title":"<code>dv</code>  Build Outputs","text":"<p>Output directory:</p> <pre><code>&lt;outdir&gt;/builds/&lt;rad_design&gt;.&lt;hash&gt;\n</code></pre> <p>The hash is a 10-character SHA-1 fingerprint computed from build-affecting parameters: simulator type, waveform settings (enabled/format), and user build arguments. This ensures identical build configurations reuse the same directory while different configurations get separate builds.</p> <p>Key files:</p> File Description <code>build.log</code> Complete build log from the simulator (Verilator/Icarus) <code>manifest.json</code> Build metadata including status (started/built/failed), timestamp, simulator config, waveform settings, build arguments, and fingerprint for reproducibility <code>srclist.abs.f</code> Absolutized source file list with include paths, generated from the design's rtl/srclist.f"},{"location":"dv/#dv-test-outputs","title":"<code>dv</code>  Test Outputs","text":"<p>Output directory:</p> <pre><code>&lt;outdir&gt;/tests/&lt;build-dir-name&gt;.&lt;test&gt;.&lt;seed&gt;\n</code></pre> <p>Key files:</p> File Description <code>test.log</code> Complete test execution log including cocotb/pyuvm output <code>manifest.json</code> Test result metadata including status (PASS/FAIL), expected result, duration, replay command, build/test directories, and full context snapshot <code>waves.fst</code> or <code>waves.vcd</code> Waveform file (if <code>--waves=1</code>) in the specified format"},{"location":"dv/#2-dv-regress-yamldriven-regression-runner","title":"2. <code>dv-regress</code> \u2014 YAML\u2011Driven Regression Runner","text":""},{"location":"dv/#dv-regress-purpose","title":"<code>dv-regress</code> Purpose","text":"<ul> <li>Execute YAML-defined regression test suites with strict configuration management</li> <li>Apply global default arguments to all jobs with per-job override capability</li> <li>Run multiple test jobs one at a time with automatic pass/fail tracking</li> <li>Generate colored summary reports with copy-pasteable replay commands for failed tests</li> <li>Let <code>dv</code> handle seeds for consistent multi-seed support</li> </ul>"},{"location":"dv/#dv-regress-typical-usage","title":"<code>dv-regress</code> Typical Usage","text":"<pre><code>dv-regress --file=src/abe/rad/rad_cdc_sync/dv/dv_regress.yaml\nmake DESIGN=rad_cdc_sync dv-regress-design\n</code></pre>"},{"location":"dv/#dv-regress-arguments","title":"<code>dv-regress</code> Arguments","text":"Argument Type Required Default Description <code>--file</code> path Yes - Path to dv_regress.yaml configuration file <code>--outdir</code> string No <code>out_dv</code> Output directory for build and test artifacts"},{"location":"dv/#3-dv-regress-all-run-all-rad-regressions","title":"3. <code>dv-regress-all</code> \u2014 Run All RAD Regressions","text":""},{"location":"dv/#dv-regress-all-purpose","title":"<code>dv-regress-all</code> Purpose","text":"<p>Searches all directories for <code>dv_regress.yaml</code> files in the repository and runs each regression using <code>dv-regress</code>. All regressions share the same output directory for unified result tracking.</p>"},{"location":"dv/#dv-regress-all-typical-usage","title":"<code>dv-regress-all</code> Typical Usage","text":"<pre><code>dv-regress-all\nmake dv-regress-all\n</code></pre>"},{"location":"dv/#dv-regress-all-arguments","title":"<code>dv-regress-all</code> Arguments","text":"Argument Type Required Default Description <code>--roots</code> list No <code>[.]</code> Root directories to scan for dv_regress.yaml files (can specify multiple) <code>--outdir</code> string No <code>out_dv</code> Output directory for build and test artifacts"},{"location":"dv/#4-dv-report-summaries-reporting","title":"4. <code>dv-report</code> \u2014 Summaries &amp; Reporting","text":""},{"location":"dv/#dv-report-purpose","title":"<code>dv-report</code> Purpose","text":"<p>Scans test output directories for manifest files and generates an organized report of expected/unexpected passes and failures with copy-pasteable replay commands.</p>"},{"location":"dv/#dv-report-typical-usage","title":"<code>dv-report</code> Typical Usage","text":"<pre><code>dv-report\nmake dv-report\n</code></pre>"},{"location":"dv/#dv-report-arguments","title":"<code>dv-report</code> Arguments","text":"Argument Type Required Default Description <code>--outdir</code> string No <code>out_dv</code> Output directory to scan for test results"},{"location":"dv/#5-dv-make-bench-autogenerate-a-new-dv-bench","title":"5. <code>dv-make-bench</code> \u2014 Auto\u2011Generate a New DV Bench","text":"<p>Creates a new bench from the template in <code>src/abe/rad/rad_template/dv</code>.</p>"},{"location":"dv/#dv-make-bench-purpose","title":"<code>dv-make-bench</code> Purpose","text":"<ul> <li>Generate complete testbench directory structure from template for new designs</li> <li>Use consistent naming across snake_case, PascalCase, and UPPER_CASE contexts</li> <li>Insert copyright headers with specified author and year</li> <li>Clean up template-specific directives for production-ready code</li> <li>Run static analysis tools on generated files to find remaining FIXME items</li> </ul>"},{"location":"dv/#dv-make-bench-typical-usage","title":"<code>dv-make-bench</code> Typical Usage","text":"<pre><code>dv-make-bench &lt;rad_design&gt; 'George Nakashima'\n</code></pre>"},{"location":"dv/#dv-make-bench-arguments","title":"<code>dv-make-bench</code> Arguments","text":"Argument Type Required Default Description <code>module_name</code> string Yes - Module name (e.g., 'rad_async_fifo' or 'RadAsyncFifo') - converted to appropriate case as needed <code>author</code> string Yes - Author name for copyright headers <code>--year</code> int No Current year Year for copyright headers <code>--force</code> flag No <code>False</code> Overwrite existing directory if it exists"},{"location":"dv/#regression-guidelines","title":"Regression Guidelines","text":"<p>The <code>dv_regress.yaml</code> file defines regression test jobs using YAML. Each bench includes this file to enable <code>dv-regress</code> execution.</p>"},{"location":"dv/#schema","title":"Schema","text":"<pre><code># Optional: Global defaults applied to all jobs\ndefaults:\n  args: [\"--sim=verilator\", \"--waves=0\"]\n\n# Required: List of test jobs\njobs:\n  - name: &lt;job_name&gt;\n    args: [\"--design=...\", \"--test=...\", \"--nseeds=N\", ...]\n  - name: &lt;job_name2&gt;\n    args: \"--design=... --test=...\"  # Single string also supported\n</code></pre>"},{"location":"dv/#job-arguments","title":"Job Arguments","text":"<p>Each job's <code>args</code> can be:</p> <ul> <li>List of strings: <code>[\"--design=rad_foo\", \"--test=test_rad_foo\"]</code></li> <li>Single string: <code>\"--design=rad_foo --test=test_rad_foo\"</code></li> </ul> <p>Arguments are passed directly to <code>dv</code>, supporting all <code>dv</code> command-line options (see <code>dv</code> Arguments table).</p>"},{"location":"dv/#common-patterns","title":"Common Patterns","text":"<p>Basic regression with multiple seeds:</p> <pre><code>jobs:\n  - name: base\n    args:\n      - --design=rad_async_fifo\n      - --test=test_rad_async_fifo\n      - --nseeds=10\n      - --seed-base=1999\n</code></pre> <p>Multiple configurations:</p> <pre><code>jobs:\n  - name: normal\n    args:\n      - --design=rad_cdc_sync\n      - --test=test_rad_cdc_sync\n      - --nseeds=2\n      - --seed-base=1999\n\n  - name: metastability_simulation\n    args:\n      - --design=rad_cdc_sync\n      - --test=test_rad_cdc_sync\n      - --build-arg=-DSIMULATE_METASTABILITY\n      - --nseeds=2\n      - --seed-base=12345\n      - --check-en=0\n</code></pre> <p>Expected failures (negative testing):</p> <pre><code>jobs:\n  - name: expect_fail\n    args:\n      - --design=rad_cdc_sync\n      - --test=test_rad_cdc_sync\n      - --build-arg=-DSIMULATE_METASTABILITY\n      - --nseeds=2\n      - --seed-base=67890\n      - --expect=FAIL\n</code></pre> <p>Using global defaults:</p> <pre><code>defaults:\n  args:\n    - --sim=verilator\n    - --waves=0\n    - --nseeds=5\n\njobs:\n  - name: job1\n    args: [\"--design=rad_foo\", \"--test=test_rad_foo\"]\n  - name: job2\n    args: [\"--design=rad_bar\", \"--test=test_rad_bar\", \"--nseeds=10\"]  # Overrides default\n</code></pre>"},{"location":"dv/#guidelines","title":"Guidelines","text":"<ol> <li>Job names: Use descriptive names for easy identification in reports</li> <li>Required args: Each job needs to specify <code>--design</code> and <code>--test</code></li> <li>Seeds: Use <code>--nseeds</code> for random seeds or <code>--seeds</code> for explicit values</li> <li>Build variants: Use <code>--build-arg</code> for RTL compilation flags</li> <li>Defaults: Use global defaults to reduce repetition across jobs</li> <li>Job args override defaults: Per-job arguments take precedence over global defaults</li> </ol>"},{"location":"dv/#example-files","title":"Example Files","text":"<p>See existing regression files for reference:</p> <ul> <li><code>src/abe/rad/rad_async_fifo/dv/dv_regress.yaml</code> - Simple single-job regression</li> <li><code>src/abe/rad/rad_cdc_sync/dv/dv_regress.yaml</code> - Multiple configurations including negative tests</li> <li><code>src/abe/rad/rad_cdc_mcp/dv/dv_regress.yaml</code> - Basic pattern</li> </ul>"},{"location":"dv/#verifying-a-new-rad-design","title":"Verifying a New RAD Design","text":""},{"location":"dv/#1-create-a-bench-from-a-suitable-template","title":"1. Create a Bench from a Suitable Template","text":"<p>Choose a starting point based on your design's characteristics:</p> Template Clocks Agents Best For <code>dv-make-bench</code> 1 1 Common single-clock designs with registered outputs <code>rad_cdc_sync</code> 1 1 Single-clock pipelines <code>rad_cdc_mcp</code> 2 2 Dual-clock handshake protocols (both domains registered) <code>rad_async_fifo</code> 2 2 Dual-clock designs with combinational outputs"},{"location":"dv/#single-clock-designs","title":"Single-Clock Designs","text":"<p>For designs with a single clock/reset domain and a single agent:</p> <ol> <li>Run <code>dv-make-bench &lt;module_name&gt; '&lt;Author Name&gt;'</code> to generate the template</li> <li>Replace all <code>NotImplementedError</code> and <code>FIXME</code> markers with design-specific logic</li> <li>Reference <code>rad_cdc_sync</code> bench for implementation examples</li> </ol>"},{"location":"dv/#multi-clock-multi-agent-designs","title":"Multi-Clock / Multi-Agent Designs","text":"<p>For designs with multiple independent clock domains or requiring separate agents per domain:</p> <ol> <li>Copy the bench most similar to your design (<code>rad_cdc_mcp</code> or <code>rad_async_fifo</code>)</li> <li>Rename all files and classes to match your design</li> <li>Customize the agent count, clock configurations, and reset routing in the environment and test classes.</li> <li>See the README.md files in these benches for dual-agent architecture patterns</li> </ol>"},{"location":"dv/#output-timing-considerations","title":"Output Timing Considerations","text":"<p>How you implement monitors depends on output timing and protocol complexity:</p> <ul> <li> <p>Simple registered outputs: Use <code>BaseMonitorOut</code> directly</p> <ul> <li>Example: <code>rad_cdc_sync</code> - output updates same cycle, sampled at standard timing</li> </ul> </li> <li> <p>Pipelined registered outputs: Extend <code>BaseMonitorOut</code> with cycle tracking</p> <ul> <li>Example: <code>rad_cdc_mcp</code> - <code>bdata</code> updates one cycle after <code>bload &amp;&amp; bvalid</code></li> <li>Monitor uses <code>_prev_load_pending</code> to track when valid data is available</li> <li>Only emits transactions when actual data transfer completes</li> </ul> </li> <li> <p>Conditional sampling: Override <code>run_phase()</code> to filter transactions</p> <ul> <li>Examples: Both <code>rad_async_fifo</code> and <code>rad_cdc_mcp</code></li> <li>Only send transactions to analysis port when transfer conditions are met</li> <li>Prevents scoreboard from checking invalid/idle cycles</li> </ul> </li> </ul> <p>Most simple designs have registered outputs and can use <code>BaseMonitorOut</code> unchanged. For pipelined protocols or conditional sampling, reference the existing benches for patterns.</p>"},{"location":"dv/#2-implement-core-components","title":"2. Implement Core Components","text":"<p>Customize these design-specific files:</p> <ul> <li> <p>Item (<code>rad_&lt;design&gt;_item.py</code>): Define input and output fields</p> <ul> <li>Implement <code>_in_fields()</code> and <code>_out_fields()</code> methods</li> <li>Add any design-specific constraints or configuration parameters</li> </ul> </li> <li> <p>Driver (<code>rad_&lt;design&gt;_driver.py</code>): Drive design inputs with proper timing</p> <ul> <li>Set <code>initial_dut_input_values</code> for reset state</li> <li>Implement <code>drive_item()</code> to apply transactions on drive edges</li> <li>Handle backpressure or protocol requirements</li> </ul> </li> <li> <p>Monitors (<code>rad_&lt;design&gt;_monitor_in.py</code>, <code>rad_&lt;design&gt;_monitor_out.py</code>): Observe design signals</p> <ul> <li>Input monitor: Sample inputs for reference model</li> <li>Output monitor: Sample outputs for scoreboard comparison</li> <li>Implement <code>sample_dut()</code> to capture signal values</li> </ul> </li> <li> <p>Reference Model (<code>rad_&lt;design&gt;_ref_model.py</code>): Compute expected behavior</p> <ul> <li>Implement <code>calc_exp()</code> to predict design outputs from inputs</li> <li>Maintain internal state matching design behavior</li> <li>Handle <code>reset_change()</code> for proper state initialization</li> </ul> </li> <li> <p>Sequence (<code>rad_&lt;design&gt;_sequence.py</code>): Generate stimulus patterns</p> <ul> <li>Implement <code>set_item_inputs()</code> to randomize or set input field values</li> <li>Configure sequence length via <code>RAD_&lt;DESIGN&gt;_SEQ_LEN</code> environment variable</li> </ul> </li> <li> <p>Coverage (<code>rad_&lt;design&gt;_coverage.py</code>): Define functional coverage</p> <ul> <li>Use <code>@CoverPoint</code> decorators from cocotb-coverage</li> <li>Implement <code>write()</code> method to sample coverage from transactions</li> </ul> </li> </ul>"},{"location":"dv/#3-develop-tests","title":"3. Develop Tests","text":"<p>All tests need to:</p> <ol> <li>Inherit from <code>BaseTest</code></li> <li>Implement <code>set_factory_overrides()</code> to register design-specific components</li> <li>Use <code>@pyuvm.test()</code> decorator</li> </ol> <p>Single-clock example:</p> <pre><code>@pyuvm.test()\nclass RadCdcSyncBaseTest(BaseTest):\n    \"\"\"Execute basic RadCdcSync test.\"\"\"\n\n    def set_factory_overrides(self) -&gt; None:\n        override = pyuvm.uvm_factory().set_type_override_by_type\n        override(BaseCoverage, RadCdcSyncCoverage)\n        ...\n</code></pre> <p>Multi-clock example:</p> <p>For designs with multiple clocks/resets, create clock and reset drivers in the test. Reference <code>rad_cdc_mcp</code> and <code>rad_async_fifo</code>.</p>"},{"location":"dv/#4-create-regression-configuration","title":"4. Create Regression Configuration","text":"<p>Add <code>dv_regress.yaml</code> to define test jobs (see Regression Guidelines).</p>"},{"location":"dv/#5-run-debug","title":"5. Run &amp; Debug","text":"<p>Run single test:</p> <pre><code>dv --design=rad_&lt;design&gt; --test=test_rad_&lt;design&gt; --waves=1\n</code></pre> <p>View waveforms:</p> <pre><code>surfer out_dv/tests/rad_&lt;design&gt;.*/waves.fst\n</code></pre> <p>Run regression:</p> <pre><code>make DESIGN=rad_&lt;design&gt; dv-regress-design\n</code></pre> <p>Evaluate coverage:</p> <p>Current RAD examples use simple counters logged during <code>report_phase()</code>. Check test logs for coverage summaries:</p> <pre><code>grep -A5 \"Coverage summary\" out_dv/tests/*/test.log\n</code></pre> <p>Note: The <code>BaseCoverage</code> class supports cocotb-coverage with <code>@CoverPoint</code> decorators for database-driven coverage collection and merging. To use this feature:</p> <ol> <li>Import decorators: <code>from cocotb_coverage.coverage import CoverPoint, CoverCross</code></li> <li>Decorate the <code>sample()</code> method with coverpoints</li> <li>Set <code>COV_YAML=path/to/output.yaml</code> to export coverage database</li> <li>Use <code>coverage_db</code> API for merging and reporting across multiple test runs</li> </ol> <p>Debug tips:</p> <ul> <li>Enable verbose logging: <code>--verbosity=debug</code></li> <li>Check test log: <code>out_dv/tests/&lt;test_dir&gt;/test.log</code></li> <li>Review manifest: <code>out_dv/tests/&lt;test_dir&gt;/manifest.json</code></li> <li>Use <code>self.logger.debug()</code> in components for detailed tracing</li> </ul>"},{"location":"dv/#6-document","title":"6. Document","text":"<p>Complete the bench documentation:</p> <ul> <li>Module docstrings: Explain purpose and usage of each component</li> <li>README.md: Architecture, design rationale, protocol details, examples</li> <li>dv_regress.yaml: Add descriptive job names and comments for complex configurations</li> </ul>"},{"location":"dv/#faq","title":"FAQ","text":""},{"location":"dv/#can-i-use-rad-dv-with-commercial-simulators","title":"Can I use RAD DV with commercial simulators?","text":"<p>Yes, with caveats:</p> <ul> <li>cocotb supports VCS, Questa, Xcelium, and others</li> <li>RAD DV tools (<code>dv</code>, <code>dv-regress</code>) currently only configure Verilator and Icarus Verilog</li> <li>Extending to commercial simulators requires license access for testing</li> </ul> <p>The testbench code itself is simulator-agnostic.</p>"},{"location":"dv/#why-do-regression-tests-run-sequentially-instead-of-in-parallel","title":"Why do regression tests run sequentially instead of in parallel?","text":"<p>Parallel execution is a future enhancement. For faster regressions, consider:</p> <ul> <li>Running multiple <code>dv-regress</code> instances on different machines</li> <li>Reducing <code>--nseeds</code> for smoke testing</li> <li>Using <code>--cmd=test</code> to skip redundant rebuilds</li> </ul>"},{"location":"dv/#why-use-uvm-methodology-with-python-instead-of-pure-cocotb","title":"Why use UVM methodology with Python instead of pure cocotb?","text":"<p>UVM provides:</p> <ul> <li>Proven patterns for testbench architecture</li> <li>Standardized components (agents, scoreboards, coverage)</li> <li>Familiar structure for verification engineers</li> <li>Reusability across designs through base classes</li> </ul> <p>Pure cocotb is excellent for simple testbenches. For complex block-level verification, RAD DV benefits from UVM's structural framework.</p>"},{"location":"dv/#can-i-use-systemverilog-assertions-with-rad-dv","title":"Can I use SystemVerilog assertions with RAD DV?","text":"<p>Yes. SVA assertions in RTL are fully supported by Verilator and Icarus Verilog. They complement the Python testbench by checking protocol compliance and design constraints at the RTL level. See also RAD Formal for property-based verification.</p>"},{"location":"dv/#why-separate-monitors-for-inputs-and-outputs","title":"Why separate monitors for inputs and outputs?","text":"<p>This mirrors UVM best practices:</p> <ul> <li>Input monitors capture stimulus for the reference model</li> <li>Output monitors capture design responses for checking</li> <li>Clean separation enables independent sampling and timing</li> <li>Reusability across different verification strategies</li> </ul> <p>See Cliff Cummings' \"Applying stimulus and sampling outputs\" paper (Literature section).</p>"},{"location":"dv/#how-do-i-debug-a-failing-test","title":"How do I debug a failing test?","text":"<ol> <li>Check the test log: <code>out_dv/tests/&lt;test_dir&gt;/test.log</code></li> <li>Enable verbose logging: <code>dv --design=&lt;design&gt; --test=&lt;test&gt; --verbosity=debug</code></li> <li>View waveforms: <code>dv --design=&lt;design&gt; --test=&lt;test&gt; --waves=1</code>, then <code>surfer out_dv/tests/*/waves.fst</code></li> <li>Add debug logging: Use <code>self.logger.debug()</code> in components</li> <li>Check manifest: Review <code>out_dv/tests/&lt;test_dir&gt;/manifest.json</code> for test configuration</li> </ol>"},{"location":"dv/#when-should-i-use-multiple-agents","title":"When should I use multiple agents?","text":"<p>Use multiple agents when:</p> <ul> <li>Independent clock domains (e.g., <code>rad_async_fifo</code>, <code>rad_cdc_mcp</code>)</li> <li>Separate interfaces with independent protocols</li> <li>Different timing domains require isolated control</li> </ul> <p>Single agent is sufficient for:</p> <ul> <li>Single clock domain designs</li> <li>Simple pipelines (e.g., <code>rad_cdc_sync</code>)</li> </ul>"},{"location":"dv/#why-doesnt-my-reference-model-match-the-design","title":"Why doesn't my reference model match the design?","text":"<p>Common issues:</p> <ul> <li>Reset initialization: Ensure reference model resets in <code>reset_change()</code></li> <li>Timing: Check that monitors sample at correct clock edges</li> <li>Pipeline delays: Account for design latency in reference model</li> <li>Edge cases: Verify reference model handles corner cases (empty, full, etc.)</li> </ul> <p>Add debug logging to both reference model and monitors to trace mismatches.</p>"},{"location":"dv/#how-do-i-add-a-new-test-to-an-existing-bench","title":"How do I add a new test to an existing bench?","text":"<ol> <li>Add test function to <code>test_&lt;design&gt;.py</code> with <code>@pyuvm.test()</code> decorator</li> <li>Inherit from BaseTest or existing test class</li> <li>Override <code>set_factory_overrides()</code> if using custom components</li> <li>Add to regression: Update <code>dv_regress.yaml</code> with new job</li> </ol>"},{"location":"dv/#references","title":"References","text":"<ul> <li>Universal Verification Methodology (UVM) 1.2 User\u2019s Guide</li> <li>UVM Class Reference Manual, Version 1.2</li> <li>cocotb</li> <li>pyuvm</li> <li>pytest</li> <li>Verilator</li> <li>Icarus Verilog</li> <li>Surfer</li> <li>GTKWave</li> <li>cocotb-coverage</li> </ul>"},{"location":"dv/#literature","title":"Literature","text":"<p>[1] R. Salemi, Python for RTL Verification: A Complete Course in Python, cocotb, and pyuvm. Boston, MA: Boston Light Press, 2022.</p> <p>[2] B. Hunter, Advanced UVM. North Charleston, SC: CreateSpace Independent Publishing Platform, 2016.</p> <p>[3] C. E. Cummings, \"uvmtb_template files\u2014An efficient and rapid way to create UVM testbenches,\" in Proc. Synopsys Users Group (SNUG), Silicon Valley, CA, 2025.</p> <p>[4] C. E. Cummings, \"Applying stimulus and sampling outputs\u2014UVM verification testing techniques,\" in Proc. Synopsys Users Group (SNUG), Austin, TX, 2016.</p> <p>[5] C. E. Cummings, \"OVM/UVM scoreboards\u2014Fundamental architectures,\" in Proc. Synopsys Users Group (SNUG), Silicon Valley, CA, 2013.</p> <p>[6] C. E. Cummings, \"The OVM/UVM factory and factory overrides\u2014How they work and why they are important,\" in Proc. Synopsys Users Group (SNUG), San Jose, CA, 2012.</p> <p>[7] C. E. Cummings and T. Fitzpatrick, \"OVM and UVM techniques for terminating tests,\" in Proc. Design and Verification Conf. (DVCon), San Jose, CA, 2011.</p>"},{"location":"dv/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"fifo_depth/","title":"FIFO Depth Tool","text":""},{"location":"fifo_depth/#fifo-depth-tool-fifo-depth","title":"FIFO Depth Tool (<code>fifo-depth</code>)","text":""},{"location":"fifo_depth/#overview","title":"Overview","text":"<p>The ABE Uarch FIFO Depth Tool computes the optimal FIFO depth and flow-control thresholds for ASIC micro-architectures. It uses Constraint Programming - Satisfiability (CP-SAT) optimization to find minimal-area solutions that satisfy latency and congestion requirements.</p> <p>Note: Throughout this document, \"CP-SAT\" is used consistently to refer to the constraint programming satisfiability solver.</p>"},{"location":"fifo_depth/#audience","title":"Audience","text":"<ul> <li>ASIC designers who need to size FIFOs precisely under complex traffic profiles.</li> <li>ASIC DV engineers who want to create stress scenarios or validate margin in performance simulations.</li> </ul>"},{"location":"fifo_depth/#purpose","title":"Purpose","text":"<ul> <li>Determine the smallest FIFO depth and thresholds that prevent underflow or overflow.</li> <li>Generate witness sequences (read/write patterns) that show the limiting case.</li> <li>For multi-clock FIFOs, find an optimal partition between asynchronous and synchronous storage.</li> </ul>"},{"location":"fifo_depth/#key-features","title":"Key Features","text":"<ul> <li>Unified solver supporting major flow-control protocols:<ul> <li>Ready / Valid</li> <li>XON/XOFF</li> <li>Credit-Based Flow Control (CBFC)</li> </ul> </li> <li>Layered traffic profile input (cycle, transaction, burst, or stream).</li> <li>Uses a deterministic algorithm to construct the worst-case write and read profiles.</li> <li>Uses a mathematical solver (CP-SAT) to find the worst peak occupancy.</li> <li>Proposes optimal Clock Domain Crossing (CDC) solution for multi-clock FIFOs.</li> <li>Replay buffer baseline solver for future expansion.</li> </ul>"},{"location":"fifo_depth/#flat-vs-layered-specifications","title":"Flat vs. Layered Specifications","text":"Spec Type Description Use Case Flat Direct FIFO parameters, explicit bounds on total read/write data over a fixed window. Simple, well-understood traffic or spreadsheet migration Layered Hierarchical profiles (cycle, transaction, burst, stream), tool derives worst-case from structure. Complex, protocol-specific, or bursty traffic"},{"location":"fifo_depth/#when-to-use-flat-vs-layered","title":"When to Use Flat vs Layered","text":"Traffic Type Recommended Spec Type Simple burst with known bounds Flat Protocol-modeled behavior Layered Unknown or exploratory behavior Layered Arbitrary bounds without structure Flat"},{"location":"fifo_depth/#known-limitations","title":"Known Limitations","text":"<ul> <li>Cannot yet model interface/storage quantum mismatches</li> <li>Threshold optimization for XON/XOFF may have long runtimes for large horizons</li> <li>No automatic data scaling for CP-SAT solver</li> <li>CDC solver assumes Gray-coded pointers and synchronizers (not handshake-based async FIFOs)</li> </ul>"},{"location":"fifo_depth/#getting-started","title":"Getting Started","text":""},{"location":"fifo_depth/#set-up-and-install","title":"Set Up and Install","text":"<p>See ABE Python Development for Python environment setup details.</p> <pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"fifo_depth/#run-examples","title":"Run Examples","text":"<pre><code>fifo-depth src/abe/uarch/fifo_depth_examples/rv_layered.yaml\nfifo-depth src/abe/uarch/fifo_depth_examples/cbfc_cdc.yaml\n</code></pre>"},{"location":"fifo_depth/#examine-outputs","title":"Examine Outputs","text":"<pre><code>ls out_uarch_fd*\ncat out_uarch_fd_rv_layered/results_scalars.json\n</code></pre>"},{"location":"fifo_depth/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>.\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 uarch\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_examples\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cbfc_balanced.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cbfc_cdc.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cbfc_flat.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cbfc_layered.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 replay_cdc.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 replay.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rv_balanced.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rv_cdc.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rv_flat.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rv_layered.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 xon_xoff_balanced.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 xon_xoff_cdc.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 xon_xoff_flat.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 xon_xoff_layered.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_base.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_cbfc.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_cdc.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_ready_valid.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_replay.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_utils.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth_xon_xoff.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 fifo_depth.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 pkt_quantize.py\n</code></pre>"},{"location":"fifo_depth/#conceptual-background","title":"Conceptual Background","text":""},{"location":"fifo_depth/#scope","title":"Scope","text":"<p>This tool models short-term congestion in data paths. The YAML specifications describe finite-duration traffic bursts where writes exceed reads. Over longer timescales, system-level flow control ensures balance; that equilibrium is beyond this tool\u2019s scope.</p> <p>A \u201cbalanced\u201d spec (equal write/read densities) requires only minimal buffering for arbitration or phase alignment. Such cases may be detected and handled analytically. The main use case is the imbalanced case \u2014 temporary write oversubscription requiring real buffering.</p>"},{"location":"fifo_depth/#motivation","title":"Motivation","text":"<p>Traditional sizing methods rely on closed-form equations or spreadsheet estimation. Those approaches may be less accurate when traffic is bursty, multi-layered, or latency-constrained. This tool computes FIFO depth using a hybrid deterministic + solver-based approach. The key idea is to combine (a) domain-specific knowledge of worst-case congestion patterns with (b) an exact optimization stage using CP-SAT. This combination provides a practical and mathematically accurate solution.</p> <p>For details on how layers compose and how worst-case patterns are generated, see How Layers Compose.</p>"},{"location":"fifo_depth/#unique-approach","title":"Unique Approach","text":""},{"location":"fifo_depth/#deterministic-construction-of-worst-case-write-and-read-profiles","title":"Deterministic Construction of Worst-Case Write and Read Profiles","text":"<p>The user\u2019s layered traffic specification (transaction, burst, and stream structure) is first compiled into binary valid profiles for the write and read sides. These profiles are not arbitrary: the tool intentionally creates worst-case congestion patterns using a set of deterministic rules.</p>"},{"location":"fifo_depth/#write-side-worst-case-maximizing-clustering-of-data","title":"Write-side Worst Case (maximizing clustering of data)","text":"<p>The write profile generator creates patterns that produce the densest possible windows of valid cycles:</p> <ul> <li>Transactions inside a burst alternate between <code>valid-first</code> and <code>gap-first</code> to create long, contiguous data regions.</li> <li>Bursts with data (D) and idles (I) are arranged using an <code>(I,D)</code> / <code>(D,I)</code> envelope based on the number of bursts:<ul> <li><code>s_cnt = 1</code>: <code>(D,I)</code></li> <li><code>s_cnt = 2</code>: <code>(I,D) (D,I)</code></li> <li><code>s_cnt = 3</code>: <code>(I,D) (D,I) (D,I)</code></li> <li><code>s_cnt = 4</code>: <code>(I,D) (D,I) (I,D) (D,I)</code></li> </ul> </li> <li>This places idles at the start and end of the stream, while concentrating data in the interior.</li> <li>For multi-burst streams, boundaries are constructed to create <code>...1 | 1...</code> transitions (\u201cCase-4\u201d behavior), known to maximize FIFO occupancy.</li> </ul>"},{"location":"fifo_depth/#read-side-worst-case-delaying-consumption","title":"Read-side Worst Case (delaying consumption)","text":"<p>The read profile generator clusters idle cycles to delay consumption:</p> <ul> <li>Every burst begins with a gap (<code>I,D</code>) to ensure reads start as late as possible.</li> <li>Transactions alternate so that gap boundaries align and create long idle runs.</li> <li>Burst boundaries aggregate idles across the stream.</li> <li>A causality guard rotates the read mask so that no read occurs before data can physically arrive, incorporating write latency.</li> </ul> <p>The result is a pair of profiles <code>(write_valid[], read_valid[])</code> that represent the worst traffic environment allowed by the user\u2019s layered specification.</p>"},{"location":"fifo_depth/#constraint-based-optimization-using-cp-sat","title":"Constraint-Based Optimization Using CP-SAT","text":"<p>The tool first generates deterministic worst-case valid masks using a congestion-packing algorithm that alternates burst phases to maximize data clustering. These binary masks define which cycles are eligible for writes and reads.</p> <p>Then, a cycle-accurate CP-SAT optimization stage determines exactly when writes and reads fire within these valid windows, while enforcing:</p> <ul> <li>FIFO causality <code>occ[t+1] = occ[t] + writes[t] - reads[t]</code></li> <li>Non-negativity <code>occ[t] \u2265 0</code></li> <li>Throughput constraints<ul> <li>total writes = <code>sum_w</code></li> <li>total reads  = <code>sum_r</code></li> </ul> </li> <li>Latency constraints<ul> <li><code>wr_latency</code>, <code>rd_latency</code></li> <li>synchronizer delays (CDC)</li> </ul> </li> </ul> <p>The solver\u2019s objective is to maximize the peak occupancy under these constraints.</p> <p>Because the deterministic masks are pre-computed input constraints that encode the worst-case timing structure, CP-SAT only needs to explore cycle-level scheduling inside those windows \u2014 which is computationally tractable while still exact.</p>"},{"location":"fifo_depth/#why-both-stages-are-necessary","title":"Why Both Stages Are Necessary","text":"<p>Using only deterministic mask construction would give plausible worst cases, but could miss problematic write/read alignments that depend on exact cycle timing.</p> <p>Using only CP-SAT would require the solver to reason about transactions, bursts, and streams directly, which is computationally impractical for realistic horizons.</p> <p>The hybrid method combines the strengths of both:</p> Component Purpose Strength Deterministic Worst-Case Mask Builder Shapes adversarial write/read behavior Fast, structured, captures known worst-case patterns CP-SAT Optimization Finds the mathematically worst alignment and firing schedule Exact, global maximum of occupancy <p>Together, they compute FIFO depths that are tight, consistent, and reliable, yet fast enough for interactive use.</p> <p>The hybrid deterministic + CP-SAT method provides a true worst-case bound for the reported depth.</p>"},{"location":"fifo_depth/#architecture","title":"Architecture","text":"<pre><code>YAML spec files (flat / layered)\n             |\n             v\n   Pydantic models + validation\n             |\n   ----------------------------\n   |                          |\n   v                          v\nTraffic compiler        CDC solver\n(layered \u2192 worst-case   (closed-form\n write/read masks)       CDC depth)\n   |                          |\n   v                          |\nCP-SAT solvers                |\n(Ready/Valid, XON/XOFF,       |\n CBFC, Replay)                |\n   \\                         /\n    \\                       /\n     v                     v\n        Core results (occ_peak,\n        thresholds, credits\u2026)\n                     |\n                     v\n     Post-processing (atomic_tail +\n          CDC + margin + rounding)\n                     |\n                     v\n      JSON / CSV / PNG / log outputs\n</code></pre> <p>Each solver (Ready/Valid, XON/XOFF, CBFC, Replay, CDC) extends <code>FifoSolver</code>. Common data structures are defined in <code>fifo_depth_base.py</code>.</p>"},{"location":"fifo_depth/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Start with a layered write/read spec</li> <li>Run fifo-depth \u2192 observe occ_peak and witness</li> <li>Apply margin/rounding</li> <li>For CDC: use CDC solver first, then feed into sync FIFO solver</li> <li>Integrate results in RTL</li> </ol>"},{"location":"fifo_depth/#file-overview","title":"File Overview","text":"File Description <code>fifo_depth.py</code> Top-level orchestrator, CLI entrypoint <code>fifo_depth_base.py</code> Common models and solver framework <code>fifo_depth_utils.py</code> Shared helper functions <code>fifo_depth_ready_valid.py</code> Ready / Valid flow control solver <code>fifo_depth_xon_xoff.py</code> XON/XOFF flow control solver <code>fifo_depth_cbfc.py</code> Credit-based flow control solver <code>fifo_depth_replay.py</code> Replay buffer solver <code>fifo_depth_cdc.py</code> CDC composition and partitioning <code>fifo_depth_examples/</code> Example YAML configurations"},{"location":"fifo_depth/#command-line-interface","title":"Command Line Interface","text":""},{"location":"fifo_depth/#arguments","title":"Arguments","text":"<p>The <code>fifo-depth</code> tool accepts the following command-line arguments:</p> Argument Type Required Default Description <code>spec</code> positional Yes \u2014 One or more YAML/JSON spec file path(s). You can specify multiple files. <code>--outdir</code> optional No See description Output directory for results files (JSON, CSV, PNG) and log file. If not specified, outputs to \"out_uarch_fd_\\&lt;spec-stem&gt;, where \\&lt;spec-stem&gt; is the stem of the spec file. <code>--results-name</code> optional No See description Prefix for results filenames. The default prefix is the name of the solver results class. <code>--verbosity</code> optional No <code>info</code> Logging level. Choices: <code>critical</code>, <code>error</code>, <code>warning</code>, <code>info</code>, <code>debug</code>."},{"location":"fifo_depth/#examples","title":"Examples","text":"<pre><code># Basic usage with single spec file\nfifo-depth src/abe/uarch/fifo_depth_examples/ready_valid.yaml\n\n# Multiple spec files\nfifo-depth spec1.yaml spec2.yaml\n\n# With custom output directory and results prefix\nfifo-depth my_spec.yaml --outdir ./results --results-name run1\n\n# With debug logging\nfifo-depth my_spec.yaml --verbosity debug\n</code></pre>"},{"location":"fifo_depth/#input-specifications","title":"Input Specifications","text":""},{"location":"fifo_depth/#types-of-specs","title":"Types of Specs","text":"<p>Two YAML specification forms are supported:</p> Type Description Flat Direct FIFO parameters (simple cases). Layered Hierarchical read/write profiles (cycle, transaction, burst, stream). <p>Flat specifications provide explicit bounds on total read and write data over a fixed horizon. Users directly specify <code>sum_w_min</code>, <code>sum_w_max</code>, <code>sum_r_min</code>, and <code>sum_r_max</code> to limit the worst-case traffic pattern. This approach works well when traffic characteristics are well-understood or when migrating from spreadsheet-based analysis. Flat specs require the user to manually calculate aggregate traffic bounds.</p> <p>Layered specifications define traffic patterns hierarchically through independent read and write profiles. Each profile can include multiple layers (e.g., cycle-level behavior, transaction grouping, burst patterns, stream periodicity) that combine to describe complex, realistic traffic. The tool automatically calculates the worst-case aggregate constraints from these layered descriptions. This approach is more intuitive for modeling protocol-specific behavior and allows the solver to explore combinations of layer parameters to find the most stressful scenario.</p>"},{"location":"fifo_depth/#data-quantities","title":"Data Quantities","text":"<p>The <code>fifo-depth</code> tool:</p> <ul> <li>Assumes that the interface data quantum matches the FIFO storage data quantum.</li> <li>Treats all data quantities as unitless integers.</li> <li>Does not automatically scale data values for the CP-SAT solver.</li> </ul> <p>Users must ensure that all write and read data parameters are specified in consistent units (e.g., bytes, words, flits) and at appropriate magnitudes for the solver.</p>"},{"location":"fifo_depth/#horizon-concept","title":"Horizon Concept","text":"<p>The horizon defines the time window (in cycles) over which the solver analyzes traffic patterns and computes FIFO depth requirements. It represents the finite duration of the scenario being modeled \u2014 typically a burst or congestion event where write traffic temporarily exceeds read traffic.</p> <p>Key characteristics:</p> <ul> <li>Finite-duration analysis: The horizon captures a specific traffic   scenario, not steady-state equilibrium. The solver finds the worst-case FIFO   occupancy within this time window.</li> <li>Flat specs: Users specify horizon directly as a positive integer. All   traffic constraints (<code>sum_w_min</code>, <code>sum_w_max</code>, <code>sum_r_min</code>, <code>sum_r_max</code>)   apply over this fixed window.</li> <li>Layered specs: Horizon can be <code>\"auto\"</code> (recommended) or user-specified.   Auto mode computes horizon based on the traffic pattern's natural periodicity   (<code>overall_period</code>), the blind window (<code>blind_window_cycles</code>), and minimum   repetition count (<code>kmin_blocks</code>). This ensures the solver examines sufficient   pattern cycles to find worst-case alignment.</li> <li>Longer horizons: Generally capture more realistic worst-case scenarios but   increase solver runtime. For layered specs, the auto-computed horizon balances   coverage and efficiency.</li> </ul> <p>The horizon does not model long-term system-level flow control or equilibrium \u2014 it focuses on short-term congestion that requires buffering.</p> <p>Horizon Sufficiency Check: The solver checks if the specified horizon may be too short to observe the maximum FIFO occupancy. The check uses this formula:</p> <pre><code>horizon &gt;= (sum_w_max / w_max) + (sum_r_max / r_max)\n</code></pre> <p>This check ensures there are enough cycles to write the maximum write traffic (<code>sum_w_max</code> at rate <code>w_max</code>) and read the maximum read traffic (<code>sum_r_max</code> at rate <code>r_max</code>). If the horizon is shorter than this threshold, a warning is issued showing that the computed FIFO depth may be underestimated. This check is most important for protocols without flow control (e.g., <code>ready_valid</code>) where occupancy can reach <code>sum_w_max</code>. Protocols with flow control (e.g., <code>xon_xoff</code>, <code>cbfc</code>) typically have lower occupancy limits because of their flow control mechanisms.</p>"},{"location":"fifo_depth/#common-parameters","title":"Common Parameters","text":"<p>All solvers use these YAML parameters:</p> Parameter Type Required Default Description <code>fifo_type</code> string Yes \u2014 FIFO protocol type. Choices: <code>ready_valid</code>, <code>xon_xoff</code>, <code>cbfc</code>, <code>replay</code>, <code>cdc</code>. <code>margin_type</code> string No <code>\"absolute\"</code> Type of margin to apply. Choices: <code>percentage</code>, <code>absolute</code>. <code>margin_val</code> int No <code>0</code> Margin value (non-negative). Interpreted based on <code>margin_type</code>. <code>rounding</code> string No <code>\"none\"</code> Rounding strategy for final depth. Choices: <code>power2</code>, <code>none</code>."},{"location":"fifo_depth/#flat-spec-parameters","title":"Flat Spec Parameters","text":"<p>The Ready / Valid, XON / XOFF, and CBFC solvers use these YAML parameters for flat specs:</p> Parameter Type Required Default Description <code>horizon</code> int Yes \u2014 Number of cycles to model (positive integer). <code>wr_latency</code> int No <code>0</code> Write latency in cycles (non-negative). <code>rd_latency</code> int No <code>0</code> Read latency in cycles (non-negative). <code>w_max</code> int No <code>1</code> Maximum write data per cycle (non-negative). <code>r_max</code> int No <code>1</code> Maximum read data per cycle (non-negative). <code>sum_w_min</code> int Yes \u2014 Minimum total write data over horizon (non-negative). <code>sum_w_max</code> int Yes \u2014 Maximum total write data over horizon (non-negative, \u2265 <code>sum_w_min</code>). <code>sum_r_min</code> int Yes \u2014 Minimum total read data over horizon (non-negative). <code>sum_r_max</code> int Yes \u2014 Maximum total read data over horizon (non-negative, \u2265 <code>sum_r_min</code>)."},{"location":"fifo_depth/#layered-spec-parameters","title":"Layered Spec Parameters","text":"<p>The Ready / Valid, XON / XOFF, and CBFC solvers use these YAML parameters for layered specs:</p> Parameter Type Required Default Description <code>horizon</code> int or string No <code>\"auto\"</code> Number of cycles to model. Can be <code>\"auto\"</code> (recommended) to automatically compute based on <code>overall_period</code>, <code>blind_window_cycles</code>, and <code>kmin_blocks</code>, or a user-specified positive integer (will be rounded up to multiple of <code>overall_period</code>). <code>wr_latency</code> int No <code>0</code> Write latency in cycles (non-negative). <code>rd_latency</code> int No <code>0</code> Read latency in cycles (non-negative). <code>kmin_blocks</code> int No <code>4</code> Minimum number of complete periods to include in auto-computed horizon. Ensures sufficient repetition of layered traffic pattern. Must be \u2265 1. <code>blind_window_cycles</code> int No <code>0</code> Number of cycles during which reads cannot observe writes (e.g., round-trip latency). Auto-computed horizon ensures at least <code>4 \u00d7 blind_window_cycles</code> to capture worst-case behavior. Must be \u2265 0."},{"location":"fifo_depth/#layered-profiles","title":"Layered Profiles","text":"<p>Layered specs specify independent write and read traffic profiles using a hierarchical structure. Both <code>write_profile</code> and <code>read_profile</code> use identical YAML parameters organized into four layers that build upon each other to create complex, realistic traffic patterns.</p> <p>Layer Structure:</p> <p>Each profile is composed of up to 4 layers that define traffic at increasing levels of granularity:</p> <ol> <li>Cycle Layer (optional): Defines the maximum data items per cycle</li> <li>Transaction Layer (required): Defines active and idle periods within a transaction</li> <li>Burst Layer (required): Defines how transactions are grouped with inter-burst gaps</li> <li>Stream Layer (optional): Defines how bursts are grouped with inter-stream gaps</li> </ol> <p>Layer Parameters:</p> Layer Parameter Type Required Default Description Cycle <code>cycle.max_items_per_cycle</code> int No <code>1</code> Maximum data items that can be transferred in a single cycle (\u2265 1). Transaction <code>transaction.valid_cycles</code> int Yes \u2014 Number of active cycles in a transaction (\u2265 0). Transaction <code>transaction.gap_cycles</code> int Yes \u2014 Number of idle cycles in a transaction (\u2265 0). Burst <code>burst.transactions_per_burst</code> int Yes \u2014 Number of transactions in each burst (\u2265 1). Burst <code>burst.gap_cycles</code> int Yes \u2014 Number of idle cycles between bursts (\u2265 0). Stream <code>stream.bursts_per_stream</code> int No <code>1</code> Number of bursts in each stream (\u2265 1). Stream <code>stream.gap_cycles</code> int No <code>0</code> Number of idle cycles between streams (\u2265 0). <p>The <code>fifo-depth</code> tool composes write and read patterns to trigger the worst-case FIFO occupancy. See the How Layers Compose section of the Appendix for details.</p> <p>Example:</p> <pre><code>write_profile:\n  cycle:\n    max_items_per_cycle: 2\n  transaction:\n    valid_cycles: 4\n    gap_cycles: 2\n  burst:\n    transactions_per_burst: 8\n    gap_cycles: 16\n  stream:\n    bursts_per_stream: 3\n    gap_cycles: 32\n</code></pre> <p>This creates a write pattern where:</p> <ul> <li>Up to 2 data items can be written per active cycle</li> <li>Each transaction has 4 active cycles, then 2 idle cycles (period = 6)</li> <li>Each burst has 8 transactions, then 16 idle cycles (period = 8\u00d76 + 16 = 64)</li> <li>Each stream has 3 bursts, then 32 idle cycles (period = 3\u00d764 + 32 = 224)</li> </ul>"},{"location":"fifo_depth/#outputs","title":"Outputs","text":"File Description <code>results_scalars.json</code> Key numeric results (depth, thresholds, margins) <code>results_witness.csv</code> Read/write occupancy sequence producing worst-case depth <code>results_plot.png</code> Graphical witness visualization <code>run.log</code> Log of parameters, solver stats, and final results <code>cdc_results_scalars.json</code> Additional results for CDC partitioning <p>Example console output:</p> <pre><code>2025-11-13 07:34:09 - abe.uarch.fifo_depth_base - INFO - results:\n{\n  \"basic_checks_pass\": true,\n  \"msg\": \"\",\n  \"depth\": 36,\n  \"occ_peak\": 32,\n  \"xon\": 15,\n  \"xoff\": 31,\n  \"t_star\": 227\n}\n2025-11-13 07:34:10 - abe.utils - INFO - XonXoffResults: results.basic_checks_pass=True\n2025-11-13 07:34:10 - abe.utils - INFO - Completed src/abe/uarch/fifo_depth_examples/xon_xoff_layered.yaml in 0:02:17\n</code></pre>"},{"location":"fifo_depth/#common-results","title":"Common Results","text":"<p>The Ready / Valid, XON/XOFF, and CBFC solvers produce these common results:</p> Field Type Description <code>basic_checks_pass</code> bool Internal validation flag showing whether the solver's self-consistency checks passed. When <code>true</code>, the results are valid. When <code>false</code>, an error occurred (e.g., peak occupancy mismatch in witness sequences) and the tool will raise an exception. <code>msg</code> str Informational message about the solution method. For CP-SAT solvers, typically empty. For CDC solver, contains <code>\"Analytic results.\"</code> to indicate closed-form calculation was used instead of constraint programming. <code>depth</code> int Recommended minimum FIFO depth. Starts with <code>occ_peak</code>, then adds: <code>atomic_tail</code> (if applicable), CDC synchronizer depth (if applicable), margin (percentage or absolute), and rounding (power-of-2 if specified). This is the final value for FIFO sizing. <code>occ_peak</code> int Peak occupancy computed by the CP-SAT solver. This is the worst-case number of data items simultaneously stored in the FIFO before any margins or adjustments are applied. <code>w_seq</code> List[int] Write sequence witness: the number of data items written to the FIFO at each cycle. This time-series demonstrates the worst-case traffic pattern that produces <code>occ_peak</code>. <code>r_seq</code> List[int] Read sequence witness: the number of data items read from the FIFO at each cycle. Combined with <code>w_seq</code>, this shows how the FIFO fills and drains over time. <code>occ_seq</code> List[int] Occupancy sequence witness: the FIFO occupancy (number of stored items) at each cycle boundary. The maximum value in this sequence equals <code>occ_peak</code>. Useful for visualizing worst-case behavior and validating the solution."},{"location":"fifo_depth/#future-enhancements","title":"Future Enhancements","text":""},{"location":"fifo_depth/#replay-solver-extensions","title":"Replay Solver Extensions","text":"<p>As noted in the Replay Solver section, the current implementation serves as a reference baseline for more complex future variants including:</p> <ul> <li>Variable round-trip time (jitter, retry delays)</li> <li>Credit windows smaller than bandwidth\u2013delay product</li> <li>Multiple senders sharing a replay buffer</li> <li>Dynamic flow control and non-uniform transmission rates</li> </ul>"},{"location":"fifo_depth/#data-quantum-and-units-support","title":"Data Quantum and Units Support","text":"<p>The tool currently has these data-related limitations:</p> <ul> <li>Assumes interface data quantum matches FIFO storage data quantum</li> <li>Treats all data quantities as unitless integers</li> <li>Does not automatically scale data values for CP-SAT solver efficiency</li> </ul> <p>Storage Quantum Mismatch:</p> <p>The first limitation can underestimate FIFO depth in certain protocols. For example, consider XON/XOFF flow control for Ethernet where FIFO storage is allocated in 64-byte words. Between when the receiver sends XOFF and the sender receives it, the worst case occurs when the sender bursts 65-byte Ethernet packets (64-byte payload + 1-byte overhead). These 65-byte packets use the most FIFO storage relative to bandwidth, but the tool currently cannot model this interface-to-storage quantum mismatch.</p> <p>Units and Autoscaling:</p> <p>Supporting units (similar to the <code>pint</code>-based approach used for CDC clock frequencies) would improve specification clarity and reduce user errors from unit inconsistencies.</p> <p>Automatic scaling would simultaneously simplify YAML specifications and optimize CP-SAT solver performance by normalizing large or small data values to efficient integer ranges.</p> <p>Implementation Approach:</p> <p>The recommended enhancement strategy:</p> <ol> <li>Add preprocessing stage to read user YAML, translate units, autoscale values,    and generate normalized YAML for existing solvers</li> <li>Keep current solver implementations unchanged</li> <li>Add postprocessing stage to reverse scaling and restore units in results</li> </ol> <p>This approach preserves the existing solver architecture while providing a cleaner user interface.</p>"},{"location":"fifo_depth/#ready-valid-solver","title":"Ready / Valid Solver","text":""},{"location":"fifo_depth/#ready-valid-purpose","title":"Ready / Valid Purpose","text":"<p>In ABE, \u201cReady / Valid\u201d is a shorthand name for a generic producer/consumer FIFO with no explicit flow-control protocol modeled inside the solver.</p> <p>This mode applies to two common architectural situations:</p> <ul> <li>Backpressured systems (e.g., actual Ready/Valid handshake)<ul> <li>Overflow is prevented by deasserting ready.</li> <li>If the traffic pattern would overflow the FIFO, that means the design will   be forced to stall the producer and miss performance goals.</li> </ul> </li> <li>Drop-tolerant systems (no backpressure)<ul> <li>Overflow results in dropped data.</li> <li>If the traffic pattern would overflow the FIFO, that means the system   will drop data that should not be dropped.</li> </ul> </li> </ul> <p>Despite these architectural differences, the FIFO depth requirement is the same:</p> <p>The FIFO must be sized so that it never overflows under the worst-case   write/read schedule within the analysis horizon.</p> <p>The solver therefore focuses entirely on worst-case occupancy, not on a specific handshake protocol.</p>"},{"location":"fifo_depth/#ready-valid-parameters","title":"Ready / Valid Parameters","text":"<p>None beyond common parameters.</p> <p>This mode assumes:</p> <ul> <li>A known write-valid mask and read-valid mask over the horizon</li> <li>A known write and read bandwidth</li> <li>No explicit credit, pause, or replay mechanism</li> </ul>"},{"location":"fifo_depth/#ready-valid-results","title":"Ready / Valid Results","text":"<p>None beyond common results.</p> <p>The depth returned guarantees:</p> <ul> <li>No overflow over the horizon</li> <li>Independent of whether the surrounding system uses Ready/Valid backpressure or allows drops</li> </ul>"},{"location":"fifo_depth/#ready-valid-recommendations","title":"Ready / Valid Recommendations","text":"<p>Flat Specifications:</p> <p>For flat (non-layered) specifications, the FIFO depth will always equal sum_w_max, because:</p> <ul> <li>The write-valid and read-valid masks are constant (all 1s)</li> <li>The producer can write every cycle</li> <li>Without temporal structure, the worst case is \u201cwrite the maximum burst before any reads\u201d</li> <li>Therefore the FIFO must buffer all writes in the horizon</li> </ul> <p>In this simple case, an analytical calculation is sufficient. The CP-SAT solver yields the same result but provides no optimization benefit.</p> <p>Balanced Specifications:</p> <p>When the specification is balanced (minimum read density \u2265 maximum write density), CP-SAT cannot produce a meaningful worst-case value:</p> <ul> <li>The solver attempts to delay reads indefinitely to maximize occupancy</li> <li>But in a balanced spec, reads can always catch up faster than writes</li> <li>This leads to an unbounded or overly large search space</li> </ul> <p>To avoid this, the tool automatically:</p> <ul> <li>Detects balance using <code>is_balanced()</code></li> <li>Switches to a deterministic analytical solver (<code>_get_results_analysis()</code>)</li> </ul> <p>This analytical method:</p> <ul> <li>Sweeps all possible write/read phase offsets</li> <li>Accounts for write and read latency</li> <li>Computes the true worst-case occupancy over the horizon</li> <li>Produces a finite, meaningful required depth</li> </ul> <p>Note:</p> <ul> <li>Layered specifications with temporal structure (bursts, gaps, cycles) provide a richer worst-case analysis space where CP-SAT does provide benefit.</li> <li>Flat and balanced cases are automatically handled using the appropriate analytical paths.</li> </ul>"},{"location":"fifo_depth/#xon-xoff-solver","title":"XON / XOFF Solver","text":""},{"location":"fifo_depth/#xon-xoff-purpose","title":"XON / XOFF Purpose","text":"<p>Models XON/XOFF flow control protocols where the receiver uses threshold-based signaling to control the sender's transmission rate. In XON/XOFF:</p> <ul> <li>The receiver monitors FIFO occupancy and asserts XOFF when occupancy reaches   the <code>xoff</code> threshold, signaling the sender to pause</li> <li>The sender reacts to XOFF after a reaction latency (<code>react_latency</code>), then   stops or throttles transmission</li> <li>When occupancy drains below the <code>xon</code> threshold, the receiver de-asserts XOFF   (signals XON)</li> <li>The sender resumes transmission after a resume latency (<code>resume_latency</code>)</li> <li>Hysteresis between <code>xon</code> and <code>xoff</code> prevents rapid toggling (control chatter)   when occupancy stays near a single threshold</li> </ul>"},{"location":"fifo_depth/#xon-xoff-overview","title":"XON / XOFF Overview","text":"<p>The XON/XOFF solver computes three critical values:</p> <ol> <li><code>depth</code> - The required FIFO buffer depth</li> <li><code>xon</code> - The threshold at which flow control is de-asserted (resume transmission)</li> <li><code>xoff</code> - The threshold at which flow control is asserted (pause transmission)</li> </ol> <p>Both <code>xon</code> and <code>xoff</code> are essential hardware parameters. They determine:</p> <ul> <li>Hysteresis behavior: The separation between pause and resume thresholds   prevents rapid toggling of flow control</li> <li>Throughput vs. depth trade-off: Lower thresholds reduce buffering but may   cause more frequent pauses, reducing effective bandwidth</li> <li>Reaction margin: Sufficient headroom above <code>xoff</code> to accommodate data   written during the writer's reaction latency</li> </ul> <p>Auto Mode vs. Manual Mode:</p> <p>The solver supports two modes:</p> <ul> <li> <p>Auto Mode (<code>thresholds=\"auto\"</code>, default): The solver automatically   computes optimal threshold values using constraint programming. It finds   threshold configurations that satisfy throughput targets while minimizing FIFO   depth, then explores the hysteresis range to balance depth, throughput, and   control stability.</p> </li> <li> <p>Manual Mode (<code>thresholds=\"manual\"</code>): You specify fixed <code>xon</code> and <code>xoff</code>   values, and the solver validates whether they provide sufficient flow control   and computes the resulting FIFO depth.</p> </li> </ul> <p>How Auto-Optimization Works:</p> <p>When <code>thresholds=\"auto\"</code> (default):</p> <ol> <li>The solver analyzes traffic patterns (write/read caps, latencies, atomic    writes, throttle rates)</li> <li>It calculates bounds for thresholds based on reaction/resume latencies and    sustained throughput requirements</li> <li>It explores candidate threshold pairs within the specified <code>hysteresis</code> range</li> <li>It optimizes based on preferences: minimize depth (default), minimize    hysteresis band (<code>prefer_small_band</code>), or minimize <code>xoff</code> (<code>prefer_low_xoff</code>)</li> <li>It validates each candidate against throughput targets and requirements</li> <li>It applies any specified margins and rounding to the final depth</li> </ol> <p>Note on adaptive optimization: The solver automatically adjusts threshold search ranges based on traffic burstiness to help ensure adequate margin for reaction latency while avoiding over-provisioning.</p>"},{"location":"fifo_depth/#xon-xoff-parameters","title":"XON / XOFF Parameters","text":"<p>XON / XOFF parameters include all common parameters plus these XON / XOFF-specific parameters:</p> Parameter Type Required Default Description <code>atomic_tail</code> int No <code>0</code> Number of data items in the final atomic write transaction that cannot be interrupted (non-negative). When the writer begins this tail transaction, it must complete even if XOFF is asserted. <code>react_latency</code> int No <code>0</code> Latency in cycles for the writer to react to XOFF assertion and stop writing (non-negative). Data continues to be written during this reaction period. <code>resume_latency</code> int No <code>0</code> Latency in cycles for the writer to resume writing after XON assertion (non-negative). No data is written during this resume period. <code>w_throttle_max</code> int No <code>0</code> Maximum number of data items that can be written per cycle while paused (non-negative). Default <code>0</code> means hard stop - no writes occur when paused. <code>thresholds</code> str No <code>\"auto\"</code> Threshold configuration mode: <code>\"manual\"</code> or <code>\"auto\"</code>. In manual mode, <code>xon</code> and <code>xoff</code> must be specified. In auto mode, the solver optimizes threshold values. <code>xon</code> int or None Conditional <code>None</code> XON threshold - occupancy level at which flow control is de-asserted and writer resumes (non-negative). Required when <code>thresholds=\"manual\"</code>, ignored in auto mode. <code>xoff</code> int or None Conditional <code>None</code> XOFF threshold - occupancy level at which flow control is asserted to pause the writer (non-negative). Required when <code>thresholds=\"manual\"</code>, ignored in auto mode. Must be \u2265 <code>xon</code> to ensure hysteresis. <code>throughput_target</code> float or \"auto\" No <code>\"auto\"</code> Target throughput ratio (0.0 to 1.0) for auto mode. When <code>\"auto\"</code>, defaults to maximum achievable throughput. Lower values allow smaller FIFO depths at the cost of reduced performance. <code>xon_min</code> int or \"auto\" No <code>\"auto\"</code> Minimum allowed XON threshold for auto mode (non-negative). When <code>\"auto\"</code>, solver computes the minimum based on resume latency and traffic patterns. Constrains the search space for threshold optimization. <code>xoff_range</code> List[int] or \"auto\" No <code>\"auto\"</code> Range of XOFF values <code>[min, max]</code> to explore in auto mode. When <code>\"auto\"</code>, solver determines the range based on traffic patterns and throughput target. Allows constraining threshold search space. <code>hysteresis</code> List[float or int] No <code>[1.0, 1.5]</code> Hysteresis range <code>[min, max]</code> as ratio between XOFF and XON thresholds. Used in auto mode to ensure separation between pause and resume levels. Both values must be \u2265 1.0, and <code>min \u2264 max</code>. Larger hysteresis reduces control chatter but may increase depth. <code>prefer_small_band</code> bool No <code>false</code> When <code>true</code>, auto mode prioritizes minimizing hysteresis band (XOFF - XON) over other optimization goals. Useful when minimizing control signal transitions is more important than depth. <code>prefer_low_xoff</code> bool No <code>false</code> When <code>true</code>, auto mode prioritizes lower XOFF values over other optimization goals. Useful when minimizing peak occupancy before flow control engages is important."},{"location":"fifo_depth/#xon-xoff-results","title":"XON / XOFF Results","text":"<p>XON / XOFF results include all common results plus these XON / XOFF-specific results:</p> Result Description <code>xon</code> Computed or validated XON threshold - the FIFO occupancy level at which flow control is de-asserted to resume writing <code>xoff</code> Computed or validated XOFF threshold - the FIFO occupancy level at which flow control is asserted to pause writing <code>throughput</code> Achieved write throughput as a ratio in [0.0, 1.0], normalized to (horizon * w_max). It is populated by the solver after witness extraction. <code>t_star</code> Earliest cycle at which peak occupancy occurs. Used as a tiebreaker in auto mode optimization when multiple threshold configurations achieve the same depth. Lower values indicate the peak occurs earlier in the horizon."},{"location":"fifo_depth/#xon-xoff-recommendations","title":"XON / XOFF Recommendations","text":"<p>Auto Mode Benefits:</p> <p>Auto mode (<code>thresholds=\"auto\"</code>) is recommended because:</p> <ol> <li> <p>Optimal Threshold Selection: The solver finds threshold configurations that minimize FIFO depth while meeting your throughput requirements, avoiding over-provisioning of buffer memory.</p> </li> <li> <p>Correct Reaction Margins: The solver automatically accounts for reaction and resume latencies, ensuring sufficient headroom above <code>xoff</code> to handle data written during the pause reaction period.</p> </li> <li> <p>Adaptive to Traffic Patterns: The solver analyzes your specific write/read profiles, atomic transactions, and throttle behavior to determine appropriate threshold values, rather than requiring manual calculation.</p> </li> <li> <p>Hysteresis Optimization: The solver explores the specified hysteresis range to balance control stability (avoiding chatter) against depth minimization.</p> </li> </ol> <p>When to Use Manual Mode:</p> <p>Manual mode is useful when:</p> <ul> <li>You have pre-existing XON/XOFF protocol specifications that must be validated</li> <li>Hardware constraints dictate specific threshold values (e.g., register width limitations)</li> <li>You want to verify that a proposed threshold configuration is sufficient for your traffic</li> </ul> <p>Recommendations:</p> <ul> <li>Consider starting with auto mode to understand the optimal thresholds for your   traffic pattern</li> <li>Use <code>hysteresis</code> (default: <code>[1.0, 1.5]</code>) to control the minimum and maximum   separation between <code>xon</code> and <code>xoff</code></li> <li>Set <code>throughput_target</code> below 1.0 if you're willing to trade some bandwidth for   reduced FIFO depth</li> <li>Use <code>prefer_small_band=true</code> to minimize hysteresis width if reducing control   signal transitions is critical</li> <li>Use <code>prefer_low_xoff=true</code> to minimize peak occupancy if you want flow control   to engage earlier</li> <li>Apply standard margin and rounding options to add implementation safety margin   to the computed depth</li> </ul>"},{"location":"fifo_depth/#cbfc-solver","title":"CBFC Solver","text":""},{"location":"fifo_depth/#cbfc-purpose","title":"CBFC Purpose","text":"<p>Models Credit-Based Flow Control (CBFC) protocols where the sender's transmission rate is regulated by credits returned asynchronously from the receiver. In CBFC:</p> <ul> <li>The sender maintains a credit pool that is decremented with each write and   incremented when credits are returned from the receiver</li> <li>Credits are returned after the receiver consumes data, subject to a return   latency (<code>cred_ret_latency</code>)</li> <li>The sender can only transmit when sufficient credits are available</li> <li>This provides backpressure without requiring a synchronous ready/valid   handshake</li> </ul>"},{"location":"fifo_depth/#cbfc-overview","title":"CBFC Overview","text":"<p>The CBFC solver computes three critical values:</p> <ol> <li><code>depth</code> - The required FIFO buffer depth</li> <li><code>cred_max</code> - The maximum size of the credit pool</li> <li><code>cred_init</code> - The initial number of credits at startup</li> </ol> <p>Both <code>cred_max</code> and <code>cred_init</code> are essential hardware implementation parameters. They determine:</p> <ul> <li>Credit pool sizing: How many credits the sender must track (affects counter   width or memory requirements)</li> <li>Startup behavior: How much data can be transmitted before the first credits   return from the receiver</li> <li>Sustained throughput: Whether the credit return rate can support the desired   bandwidth</li> </ul> <p>Auto Mode vs. Manual Mode:</p> <p>The solver supports two modes:</p> <ul> <li> <p>Auto Mode (<code>cred_max=\"auto\"</code> and/or <code>cred_init=\"auto\"</code>, default): The   solver automatically computes optimal credit values using constraint   programming. It finds the minimal feasible credit configuration that satisfies   the traffic requirements, then adds adaptive headroom based on read-valid   gapiness patterns.</p> </li> <li> <p>Manual Mode (explicit integer values): You specify fixed credit values, and   the solver validates whether they provide sufficient flow control and computes   the resulting FIFO depth.</p> </li> </ul> <p>How Auto-Optimization Works:</p> <p>When <code>cred_auto_optimize=true</code> (default) with auto mode:</p> <ol> <li>The solver analyzes traffic patterns (write/read caps, latencies, credit    return latency)</li> <li>It computes lower bounds for credits based on startup requirements and    sustained throughput</li> <li>It performs lexicographic minimization: first minimizes <code>cred_init</code>, then    minimizes <code>cred_max</code></li> <li>It adds adaptive headroom derived from the read-valid pattern's maximum gap    between valid slots</li> <li>It applies any specified margins and rounding</li> </ol> <p>Note on adaptive headroom: The solver automatically adjusts headroom based on read-valid gapiness to help ensure credits are available even when reads arrive in bursts rather than uniformly.</p>"},{"location":"fifo_depth/#cbfc-parameters","title":"CBFC Parameters","text":"<p>CBFC parameters include all common parameters plus these CBFC-specific parameters:</p> Parameter Type Required Default Description <code>cred_max</code> int or \"auto\" No <code>\"auto\"</code> Maximum credit pool size (non-negative). When <code>\"auto\"</code>, solver optimizes this value. <code>cred_init</code> int or \"auto\" No <code>\"auto\"</code> Initial credit count at start (non-negative). When <code>\"auto\"</code>, solver optimizes this value. Must be \u2264 <code>cred_max</code>. <code>cred_gran</code> int No <code>1</code> Credit granularity - number of data units per credit (non-negative). <code>cred_ret_latency</code> int No <code>0</code> Latency in cycles for credit return from receiver to sender (non-negative). <code>cred_auto_optimize</code> bool No <code>true</code> Enable automatic optimization of credit parameters when set to <code>\"auto\"</code>. <code>cred_headroom</code> int No <code>2</code> Additional headroom credits beyond computed minimum (non-negative). Used when auto-optimizing credits. <code>cred_margin_type</code> str No <code>\"absolute\"</code> Type of margin to apply to credit values: <code>\"percentage\"</code> or <code>\"absolute\"</code>. <code>cred_margin_val</code> int No <code>0</code> Margin value to add to credit calculations. <code>cred_rounding</code> str No <code>\"none\"</code> Rounding strategy for credit values: <code>\"power2\"</code> or <code>\"none\"</code>."},{"location":"fifo_depth/#cbfc-results","title":"CBFC Results","text":"<p>CBFC results include all common results plus these CBFC-specific results:</p> Result Description <code>cred_max</code> Computed or validated maximum credit pool size <code>cred_init</code> Computed or validated initial credit count <code>throughput</code> Achieved write throughput as a ratio in [0.0, 1.0], normalized to (horizon * w_max). It is populated by the solver after witness extraction."},{"location":"fifo_depth/#cbfc-recommendations","title":"CBFC Recommendations","text":"<p>Auto Mode Benefits:</p> <p>Auto mode (<code>cred_max=\"auto\"</code> and <code>cred_init=\"auto\"</code>) is recommended because:</p> <ol> <li> <p>Optimal Credit Sizing: The solver finds the minimal credit configuration    that satisfies your traffic requirements, avoiding over-provisioning of credit    counters or pools.</p> </li> <li> <p>Correct Startup Credits: The solver automatically accounts for credit    return latency and startup requirements, ensuring sufficient initial credits    to achieve desired throughput before the first credits return.</p> </li> <li> <p>Adaptive to Traffic Patterns: The solver analyzes your specific write/read    profiles and latencies to determine appropriate credit values, rather than    requiring manual calculation.</p> </li> <li> <p>Built-in Headroom: Adaptive headroom is automatically added based on    read-valid gapiness, providing protection against traffic burstiness.</p> </li> </ol> <p>When to Use Manual Mode:</p> <p>Manual mode is useful when:</p> <ul> <li>You have pre-existing credit protocol specifications that must be validated</li> <li>Hardware constraints dictate specific credit pool sizes (e.g., power-of-2   counter widths)</li> <li>You want to verify that a proposed credit configuration is sufficient</li> </ul> <p>Recommendations:</p> <ul> <li>Consider starting with auto mode to understand the minimal credit requirements   for your traffic pattern</li> <li>Use <code>cred_headroom</code> (default: 2) to add safety margin beyond the computed   minimum</li> <li>Apply <code>cred_rounding=\"power2\"</code> if your hardware prefers power-of-2 credit pool   sizes</li> <li>Use <code>cred_margin_type</code> and <code>cred_margin_val</code> to add implementation margin to   credit values</li> </ul>"},{"location":"fifo_depth/#cdc-solver","title":"CDC Solver","text":""},{"location":"fifo_depth/#cdc-purpose","title":"CDC Purpose","text":"<p>The CDC solver handles FIFO depth sizing when the write and read interfaces operate in different clock domains. It implements a two-stage approach:</p> <ol> <li>Small CDC FIFO: Handles clock domain crossing with Gray-coded pointers and    synchronizer latency</li> <li>Large synchronous FIFO: Buffers traffic patterns in a single clock domain</li> </ol> <p>This separation is preferred over a single asynchronous FIFO because:</p> <ul> <li>Gray counter logic is simpler for small, power-of-2 depths</li> <li>Most buffering depth can use simpler synchronous FIFO logic</li> <li>The CDC solver calculates both the small CDC depth and initial conditions for   the downstream synchronous solver</li> </ul>"},{"location":"fifo_depth/#cdc-overview","title":"CDC Overview","text":"<p>The CDC solver computes three critical values:</p> <ol> <li><code>depth</code> - The required small CDC FIFO buffer depth</li> <li><code>base_sync_fifo_depth</code> - The minimum depth for the large synchronous FIFO    based on long-term rate mismatch</li> <li><code>wptr_cdc_cycles_in_wr</code> - Write pointer CDC latency converted to    write-domain cycles</li> </ol> <p>These values enable a two-stage solution: the small CDC FIFO handles clock domain crossing, while the computed parameters inform stage 2's solution of the large synchronous FIFO.</p> <p>Analytic Solution vs. CP-SAT:</p> <p>Unlike other solvers (Ready/Valid, XON/XOFF, CBFC, Replay) which use CP-SAT constraint programming, the CDC solver uses closed-form analytical formulas. This works because:</p> <ul> <li>Well-defined latencies: Synchronization stages, Gray code delays, and phase   relationships have deterministic bounds</li> <li>Independent components: Synchronizer depth, phase margin, and PPM drift can   be calculated separately and summed</li> <li>No optimization needed: There are no tunable parameters to optimize (like   thresholds or credits) \u2014 the physics of clock domain crossing determines the   requirements</li> <li>Computational efficiency: Analytic formulas execute instantly, while CP-SAT   would add unnecessary overhead for a problem with a unique deterministic   solution</li> </ul> <p>The CDC depth calculation sums three components:</p> <ul> <li>Credit loop depth: Steady-state round-trip latency buffering required to   sustain maximum write throughput. Accounts for write pointer synchronization   into the read domain, read-side reaction time, read pointer synchronization   back to the write domain, and write-side full-flag update.</li> <li>Phase margin depth: One read-cycle worth of items to account for unknown   initial phase relationship between clocks</li> <li>PPM drift depth: Accumulated frequency drift over the horizon in both write   and read domains</li> </ul>"},{"location":"fifo_depth/#cdc-parameters","title":"CDC Parameters","text":"<p>CDC parameters include all common parameters plus these CDC-specific parameters:</p> Parameter Type Required Default Description <code>wr_clk_freq</code> int, float, or str Yes - Write clock frequency. Can be specified as integer Hz (e.g., <code>1000000000</code> for 1 GHz), float Hz, or string with units (e.g., <code>\"1.1 GHz\"</code>, <code>\"100 MHz\"</code>). Must be positive. <code>rd_clk_freq</code> int, float, or str Yes - Read clock frequency. Can be specified as integer Hz, float Hz, or string with units. Must be positive. <code>big_fifo_domain</code> str No <code>\"write\"</code> Clock domain for the large synchronous FIFO in stage 2: <code>\"write\"</code> or <code>\"read\"</code>. Determines which domain's cycles are used for the <code>horizon</code> and traffic pattern analysis. <code>wr_clk_ppm</code> int No <code>0</code> Write clock frequency tolerance in parts-per-million (non-negative). Used to calculate worst-case drift over the horizon. <code>rd_clk_ppm</code> int No <code>0</code> Read clock frequency tolerance in parts-per-million (non-negative). Used to calculate worst-case drift over the horizon. <code>wptr_inc_cycles</code> int No <code>0</code> Write-domain cycles to increment write pointer after a write (non-negative). <code>wptr_sync_slip_cycles</code> int No <code>1</code> Read-domain cycles for write pointer synchronization slips/metastability settling (non-negative). <code>wptr_sync_stages</code> int No <code>2</code> Number of synchronizer flip-flop stages for write pointer CDC crossing (non-negative). Typical values are 2-3 stages for MTBF requirements. <code>rd_react_cycles</code> int No <code>1</code> Read-domain cycles for read logic to react after seeing new data (non-negative). <code>rptr_inc_cycles</code> int No <code>1</code> Read-domain cycles to increment read pointer after a read (non-negative). <code>rptr_sync_slip_cycles</code> int No <code>1</code> Write-domain cycles for read pointer synchronization slips/metastability settling (non-negative). <code>rptr_sync_stages</code> int No <code>2</code> Number of synchronizer flip-flop stages for read pointer CDC crossing (non-negative). Typical values are 2-3 stages for MTBF requirements. <code>wr_full_update_cycles</code> int No <code>1</code> Write-domain cycles to update the full flag after read pointer synchronization (non-negative). <code>window_cycles</code> int or \"auto\" No <code>\"auto\"</code> Horizon size in cycles for the <code>big_fifo_domain</code>. When <code>\"auto\"</code>, extracted from <code>horizon</code> field or compiled from layered profiles. Must be positive when specified as integer."},{"location":"fifo_depth/#cdc-results","title":"CDC Results","text":"<p>The CDC-specific results are:</p> Result Description <code>depth</code> Required small CDC FIFO buffer depth (after margin and rounding). Sum of <code>credit_loop_depth</code>, <code>phase_margin_depth</code>, and <code>ppm_drift_depth</code>. <code>credit_loop_depth</code> Depth component for steady-state round-trip latency. Accounts for write pointer increment, write pointer CDC crossing, read reaction, read pointer increment, read pointer CDC crossing, and full flag update\u2014all converted to items at the write rate. <code>phase_margin_depth</code> Depth component for clock phase uncertainty. Accounts for one read cycle of uncertainty due to unknown relative phase between write and read clocks. <code>ppm_drift_depth</code> Depth component for PPM frequency drift. Accumulated worst-case drift over the horizon in both write and read domains (combined). <code>base_sync_fifo_depth</code> Minimum depth for the large synchronous FIFO in stage 2. Based on long-term rate mismatch over the window: <code>window_cycles \u00d7 items_per_cycle \u00d7 max(0, 1 - f_rd/f_wr)</code>. Only positive when write clock is faster than read clock. <code>wptr_cdc_cycles_in_wr</code> Write pointer CDC latency (time for write pointer to become visible in read domain) converted to write-domain cycles. Used as initial condition parameter for stage 2 synchronous FIFO solver's <code>rd_latency</code> adjustment. <p>Results are saved in file <code>cdc_results_scalars.json</code> in the output directory.</p>"},{"location":"fifo_depth/#cdc-recommendations","title":"CDC Recommendations","text":"<p>Margin and Rounding Strategy:</p> <p>CDC FIFOs should typically be small and power-of-2 sized for efficient Gray counter implementation. However, automatic margin and rounding can lead to excessive sizing:</p> <ul> <li>If the solver computes a depth of 13 and you specify 25% margin with   power-of-2 rounding, the result will be 32 (potentially excessive)</li> <li>Recommended approach: Set <code>margin_val=0</code> and <code>rounding=\"none\"</code> initially,   review the computed depth, then manually select an appropriate power-of-2 size</li> <li>For critical applications, consider adding 1-2 entries of margin, then rounding   up to the next power-of-2</li> </ul> <p>Clock Domain Selection:</p> <p>The <code>big_fifo_domain</code> parameter determines which clock domain is used for the large synchronous FIFO in stage 2:</p> <ul> <li>Set <code>big_fifo_domain=\"write\"</code> (default) when the write clock is faster or when   traffic patterns are naturally specified in write-domain cycles</li> <li>Set <code>big_fifo_domain=\"read\"</code> when the read clock is faster, as this may reduce   the total depth of the large synchronous FIFO</li> <li>The CDC FIFO depth is independent of this choice; only the stage 2 synchronous   FIFO is affected</li> </ul> <p>PPM Tolerance Specification:</p> <ul> <li>Set <code>wr_clk_ppm</code> and <code>rd_clk_ppm</code> to match your oscillator specifications   (e.g., 100 ppm for typical crystals)</li> <li>Omit or set to 0 if clocks are derived from the same source (frequency-locked)</li> <li>PPM drift accumulates over the horizon, so larger windows require   proportionally more depth</li> <li>Higher PPM values add safety margin but increase CDC FIFO size</li> </ul> <p>Synchronizer Stage Configuration:</p> <ul> <li>Default <code>sync_stages=2</code> is standard for most applications and provides   sufficient MTBF (Mean Time Between Failures)</li> <li>Use <code>sync_stages=3</code> for very high-speed designs or stringent reliability   requirements</li> <li><code>ptr_gray_extra=1</code> (default) accounts for Gray code sampling uncertainty;   typically no need to change</li> <li>Increasing these values improves reliability but increases synchronization   latency and CDC depth</li> </ul> <p>Analysis Window:</p> <ul> <li>Use <code>window_cycles=\"auto\"</code> (default) to inherit from the main <code>horizon</code> or   layered profile specification</li> <li>Manually specify <code>window_cycles</code> only if you need a different horizon than the   synchronous FIFO</li> <li>The window should cover the longest traffic burst or congestion period you want   to handle</li> </ul>"},{"location":"fifo_depth/#replay-solver","title":"Replay Solver","text":""},{"location":"fifo_depth/#replay-purpose","title":"Replay Purpose","text":"<p>Models replay buffers that hold unacknowledged (in-flight) data until acknowledgements (ACKs) arrive after a round-trip time (RTT). This is needed for protocols that require retransmission capability, where data must be kept until confirmed receipt.</p>"},{"location":"fifo_depth/#replay-overview","title":"Replay Overview","text":"<p>The replay FIFO model uses a CP-SAT formulation for consistency with other <code>fifo_depth_*</code> solvers. For the standard deterministic case (fixed RTT, single sender, continuous transmission at <code>w_max</code>), the solution is equivalent to the classic bandwidth\u2013delay product (BDP):</p> <pre><code>peak_inflight = min(rtt, horizon - rtt) \u00d7 w_max\n</code></pre> <p>The solver enforces that:</p> <ul> <li>Writes transmit data into the replay buffer</li> <li>Acknowledgements arrive exactly <code>rtt</code> cycles after the corresponding write</li> <li>No new writes occur in the final <code>rtt</code> cycles (ensuring the buffer drains to   zero by the horizon)</li> <li>The buffer must accommodate all in-flight (unacknowledged) data</li> </ul> <p>While the current implementation produces the same result as the analytical BDP formula, the CP-SAT solver serves as a reference implementation and extensibility placeholder for more complex future variants such as:</p> <ul> <li>Variable <code>rtt[t]</code> (jitter, retry delays)</li> <li>Credit windows smaller than BDP</li> <li>Multiple senders sharing a replay buffer</li> <li>Discrete protocol phases (pause, resume, retry)</li> <li>Dynamic flow control rules (<code>w[t]</code> \u2264 function of inflight)</li> <li>Non-uniform <code>w_max</code> (burst shaping)</li> <li>Overlapping atomic tail semantics</li> </ul> <p>Future extensions will leverage this solver framework to capture those non-trivial dynamics without requiring new analytical derivations.</p>"},{"location":"fifo_depth/#replay-parameters","title":"Replay Parameters","text":"<p>The Replay FIFO is fundamentally different from the previously described Ready / Valid, XON/XOFF, and CBFC FIFOs. It only supports flat specs (not layered profiles) and models the transmission/acknowledgement pattern directly. Layered replay is not currently supported because replay buffers inherently depend on temporal ACK structure rather than transaction/burst layering.</p> <p>Replay supports the common parameters <code>fifo_type</code>, <code>margin_type</code>, <code>margin_val</code>, and <code>rounding</code> and these replay-specific parameters:</p> Parameter Type Required Default Description <code>horizon</code> int Yes \u2014 Number of cycles to model (positive integer). Must be \u2265 <code>rtt</code>. <code>w_max</code> int No <code>1</code> Maximum write (transmit) data per cycle (non-negative). Represents the maximum bandwidth of the sender. <code>atomic_tail</code> int No <code>0</code> Additional buffer space to reserve beyond the computed in-flight peak (non-negative). Useful for protocol-specific padding or alignment requirements. <code>rtt</code> int Yes \u2014 Round-trip time in cycles (positive integer). The delay between a data transmission and its corresponding acknowledgement. Must be \u2264 <code>horizon</code>."},{"location":"fifo_depth/#replay-results","title":"Replay Results","text":"<p>The replay solver results are fundamentally the same as the common FIFO results in principle, but use more precise terminology specific to replay buffers. In a replay buffer context:</p> <ul> <li>Occupancy (occ) \u2192 Inflight (infl): The amount of data that has been transmitted but not yet acknowledged</li> <li>Read (r) \u2192 Acknowledgement (ack/a): The signal indicating data has been received and can be removed from the replay buffer</li> <li>Write (w) remains Write (w): The transmission of new data</li> </ul> <p>The mapping between common FIFO results and replay-specific results is:</p> Common Result Replay Result Description <code>depth</code> <code>depth</code> Required buffer depth <code>occ_peak</code> <code>infl_peak</code> Peak inflight data (maximum unacknowledged transmissions) <code>w_seq</code> <code>w_seq</code> Write (transmit) sequence over time <code>r_seq</code> <code>a_seq</code> Read (acknowledgement) sequence over time <code>occ_seq</code> <code>infl_seq</code> Occupancy (inflight) sequence over time <p>Why CP-SAT Yields the Same Result as the BDP Equation:</p> <p>The CP-SAT solver produces the same result as the analytical bandwidth\u2013delay product (BDP) calculation because of the specific constraints in the current Replay model:</p> <ol> <li> <p>Deterministic Acknowledgements: Every write at cycle <code>t</code> generates an    acknowledgement at cycle <code>t + rtt</code>. This creates a perfectly predictable    in-flight pattern.</p> </li> <li> <p>Maximum Transmission Rate: The solver maximizes the objective (peak    in-flight data) by transmitting at <code>w_max</code> continuously during the valid    transmission window.</p> </li> <li> <p>Drain Constraint: The requirement that no writes occur in the final <code>rtt</code>    cycles (ensuring <code>inflight[horizon] == 0</code>) creates a symmetric ramp-up and    ramp-down pattern.</p> </li> <li> <p>Peak Occurs at Predictable Time: Under continuous transmission at <code>w_max</code>,    in-flight data accumulates linearly until either:</p> </li> <li>Time <code>rtt</code> (first acknowledgements arrive), or</li> <li>Time <code>horizon - rtt</code> (last writes that will be acknowledged before horizon)</li> </ol> <p>The peak is therefore <code>min(rtt, horizon - rtt) \u00d7 w_max</code>.</p> <ol> <li>No Alternative Strategies: The CP-SAT solver explores the solution space    but finds no transmission pattern that exceeds this peak. Any change from    continuous transmission at <code>w_max</code> (e.g., pausing or reducing transmission    rate) would only reduce the in-flight accumulation.</li> </ol> <p>The CP-SAT formulation serves as a reference implementation that validates the analytical formula and provides a foundation for future extensions where analytical solutions may not exist (variable RTT, multiple senders, flow control, etc.).</p>"},{"location":"fifo_depth/#advanced-topics","title":"Advanced Topics","text":""},{"location":"fifo_depth/#performance-considerations","title":"Performance Considerations","text":"<p>Solver runtime depends on several factors:</p> <ul> <li>Horizon Length: Longer horizons increase the number of variables and   constraints, leading to longer solve times. For layered specs, auto-computed   horizons that cover many periods can significantly increase runtime. Layered   specs generate multiple periodicities whose least common multiple (LCM)   determines the horizon, which directly increases solver variables.</li> <li>Layer Complexity: Each additional layer (cycle, transaction, burst, stream)   increases the combinatorial space the solver must explore. Deeply layered   profiles with many bursts or streams are more computationally intensive.</li> <li>Spec Type: Flat specs are typically solved in seconds, as they have fewer   variables and a simpler structure. Layered specs, especially with large   horizons or many periods, may take from seconds to several minutes.</li> <li>Traffic Burstiness: Highly bursty or imbalanced profiles can create more   challenging optimization problems, increasing runtime.</li> <li>Parameter Choices: Using <code>\"auto\"</code> for horizon or specifying a large number   of periods can unintentionally create very large problem sizes. Manually   limiting the horizon or simplifying profiles can improve performance.</li> </ul> <p>Recommendations for Efficient Solving:</p> <ul> <li>Consider starting with flat specs or small horizons to validate basic behavior.</li> <li>Use layered specs for detailed analysis, but minimize the number of periods and   layers where possible.</li> <li>If solve time is excessive, consider reducing the horizon, simplifying the   traffic profile, or using fewer bursts/streams.</li> <li>Monitor solver logs for warnings about horizon sufficiency or problem size.</li> </ul> <p>In most practical cases, flat and moderately layered specs solve in under a minute. Only highly complex, deeply layered, or very long-horizon cases should require longer runtimes.</p>"},{"location":"fifo_depth/#how-layers-compose","title":"How Layers Compose","text":"<p>The tool builds a binary valid pattern (0/1 sequence) by composing layers from innermost (transaction) to outermost (stream):</p> <ul> <li>Transaction period = <code>valid_cycles</code> + <code>gap_cycles</code></li> <li>Burst = <code>transactions_per_burst</code> transactions + <code>gap_cycles</code></li> <li>Stream = <code>bursts_per_stream</code> bursts + <code>gap_cycles</code></li> <li>Overall period = LCM of write and read stream periods</li> </ul> <p>Worst-Case Pattern Generation:</p> <p>The tool uses different strategies based on whether the profile has a single burst or multiple bursts, implementing patterns from FIFO depth calculation literature to create maximum congestion:</p> <p>For Write Profiles (maximizing FIFO fill):</p> <p>Single Burst (<code>bursts_per_stream == 1</code>):</p> <ul> <li>Uniform valid-first pattern: All transactions use valid cycles followed by   gap cycles</li> <li>Maximizes clustering of valid cycles within the burst for safe depth estimation</li> <li>No burst boundaries exist to optimize</li> </ul> <p>Multiple Bursts (<code>bursts_per_stream &gt; 1</code>):</p> <ul> <li>Transaction-level alternation: Transactions within each burst alternate   between gap-first and valid-first patterns to achieve valid clustering at burst   boundaries<ul> <li>Pattern choice depends on burst index parity and <code>transactions_per_burst</code>   parity</li> <li>Odd-indexed bursts are configured to end with valid cycles</li> <li>Even-indexed bursts \u2265 2 are configured to start with valid cycles</li> </ul> </li> <li>Burst-level alternation: Bursts place gaps strategically to concentrate   data in the middle of the observation window<ul> <li>First burst (index 0): gap followed by transactions (I,D) - places idle at   start</li> <li>Last burst: transactions followed by gap (D,I) - places idle at end</li> <li>Middle bursts alternate:<ul> <li>Odd-indexed middle bursts: transactions followed by gap (D,I)</li> <li>Even-indexed middle bursts: gap followed by transactions (I,D)</li> </ul> </li> <li>Creates worst-case patterns by concentrating data centrally:<ul> <li>2 bursts: (I,D)(D,I)</li> <li>3 bursts: (I,D)(D,I)(D,I)</li> <li>4 bursts: (I,D)(D,I)(I,D)(D,I)</li> </ul> </li> </ul> </li> </ul> <p>For Read Profiles (maximizing FIFO drain delay):</p> <p>Single Burst (<code>bursts_per_stream == 1</code>):</p> <ul> <li>Uniform gap-first pattern: All transactions use gap cycles followed by valid cycles</li> <li>Maximizes delay by front-loading idle cycles within the burst</li> </ul> <p>Multiple Bursts (<code>bursts_per_stream &gt; 1</code>):</p> <ul> <li>Transaction-level alternation: Transactions alternate to cluster idle cycles at boundaries<ul> <li>Alternation pattern based on combined (burst_index + transaction_index) parity</li> <li>Even parity: valid-first then gap (boundary with next gap-first forms larger idle)</li> <li>Odd parity: gap-first then valid</li> </ul> </li> <li>Burst-level alternation: All burst gaps placed at start to maximize read delay</li> </ul> <p>Causality Preservation:</p> <ul> <li>Write patterns never start with gaps (first burst begins with transactions)</li> <li>Read patterns include warmup rotation based on write latency to ensure reads   occur after writes</li> <li>Guarantees cumulative writes \u2265 cumulative reads at all times</li> </ul> <p>This hybrid approach (uniform for single burst, alternating for multi-burst) ensures conservative FIFO depth estimates across all configurations.</p>"},{"location":"fifo_depth/#faq","title":"FAQ","text":"<p>If you encounter performance issues, the first four questions may be helpful to review first.</p>"},{"location":"fifo_depth/#why-does-the-solver-sometimes-take-several-minutes-to-run","title":"Why does the solver sometimes take several minutes to run?","text":"<p>Solver runtime is dominated by:</p> <ul> <li>Horizon length \u2014 longer windows \u2192 more variables \u2192 longer solve time</li> <li>Layer complexity \u2014 cycle + transaction + burst + stream generates deeply   nested patterns</li> <li>Burstiness / imbalance \u2014 highly adversarial patterns increase the CP-SAT   search space</li> <li>XON/XOFF auto-threshold search \u2014 exploring multiple <code>(xon, xoff)</code> candidates   can multiply solve time</li> </ul> <p>Flat specifications typically solve in seconds. Layered profiles with multiple streams/periods can take minutes. This is normal and expected based on CP-SAT complexity.</p>"},{"location":"fifo_depth/#why-does-horizon-auto-sometimes-produce-very-large-horizons","title":"Why does <code>horizon: auto</code> sometimes produce very large horizons?","text":"<p>Because the tool must ensure it covers all worst-case alignments between the write and read patterns. The auto logic includes:</p> <ul> <li>multiple full pattern periods (<code>kmin_blocks</code>)</li> <li>blind window coverage (<code>blind_window_cycles</code>)</li> <li>LCM of read/write stream periods</li> <li>safety padding</li> </ul> <p>This produces a horizon long enough to ensure correctness. If runtime is too long, you may manually set a smaller horizon\u2014but note that making it too small may underestimate FIFO depth.</p>"},{"location":"fifo_depth/#why-does-the-depth-equal-sum_w_max-for-flat-readyvalid","title":"Why does the depth equal <code>sum_w_max</code> for flat ready/valid?","text":"<p>Flat ready/valid has:</p> <ul> <li>constant write-valid = 1</li> <li>constant read-valid = 1</li> <li>no temporal structure to exploit</li> </ul> <p>The worst case is:</p> <pre><code>depth = sum_w_max\n</code></pre> <p>Because all writes can occur before any reads.</p>"},{"location":"fifo_depth/#why-does-the-solver-switch-from-cp-sat-to-analytic-mode-for-balanced-specs","title":"Why does the solver switch from CP-SAT to analytic mode for balanced specs?","text":"<p>A spec is balanced when:</p> <pre><code>(min read density) \u2265 (max write density)\n</code></pre> <p>In this case:</p> <ul> <li>reads can always drain faster than writes can fill</li> <li>CP-SAT can delay reads arbitrarily \u2192 problem becomes poorly defined</li> </ul> <p>So the solver automatically switches to a deterministic analytic solver that:</p> <ul> <li>sweeps phase alignment</li> <li>includes latencies</li> <li>calculates worst-case occupancy deterministically</li> </ul> <p>This produces a stable, meaningful result.</p>"},{"location":"fifo_depth/#why-does-the-xonxoff-solver-choose-a-higher-xoff-than-expected","title":"Why does the XON/XOFF solver choose a higher <code>xoff</code> than expected?","text":"<p>Usually because:</p> <ul> <li><code>react_latency</code> &gt; 0</li> <li><code>atomic_tail</code> &gt; 0</li> <li>the write pattern is very bursty</li> <li>throughput target must be met</li> <li>hysteresis constraints limit low values</li> <li>low <code>xoff</code> would not be feasible</li> </ul> <p>The solver must leave headroom above xoff to absorb data written during the reaction latency.</p> <p>So <code>xoff</code> increases when mathematically required for correctness.</p>"},{"location":"fifo_depth/#why-are-thresholds-or-credits-ignored-when-using-auto-mode","title":"Why are thresholds or credits ignored when using auto mode?","text":"<p>In auto mode:</p> <pre><code>thresholds: auto\ncred_max: auto\ncred_init: auto\n</code></pre> <p>the solver intentionally ignores user-specified values and computes optimal ones.</p> <p>To force manual values:</p> <pre><code>thresholds: manual\nxon: &lt;value&gt;\nxoff: &lt;value&gt;\n</code></pre> <p>or for CBFC:</p> <pre><code>cred_auto_optimize: false\ncred_max: &lt;value&gt;\ncred_init: &lt;value&gt;\n</code></pre>"},{"location":"fifo_depth/#why-is-peak-occupancy-lower-than-expected","title":"Why is peak occupancy lower than expected?","text":"<p>Common reasons:</p> <ul> <li>burst/gap structure limits congestion</li> <li>XON/XOFF throttling reduces peaks</li> <li>CBFC credit return naturally controls writes</li> <li>CDC FIFO is limited by synchronizer depth</li> </ul> <p>Many spreadsheet estimates are pessimistic; CP-SAT often finds a tighter true bound.</p>"},{"location":"fifo_depth/#why-is-peak-occupancy-higher-than-expected","title":"Why is peak occupancy higher than expected?","text":"<p>Often due to:</p> <ul> <li>adversarial phase alignment</li> <li>large blind window</li> <li>write/read latency asymmetry</li> <li>clustered burst boundaries</li> <li>XON/XOFF reaction overshoot</li> <li>CBFC credit-return latency</li> </ul> <p>The solver explores worst-case timing that may not be immediately intuitive.</p>"},{"location":"fifo_depth/#why-does-xonxoff-auto-mode-take-longer-than-other-solvers","title":"Why does XON/XOFF auto mode take longer than other solvers?","text":"<p>Because auto mode must:</p> <ol> <li>Compute feasible <code>xon_min</code></li> <li>Compute feasible <code>xoff</code> range</li> <li>Sweep hysteresis space</li> <li>Solve CP-SAT per candidate</li> <li>Choose the lexicographically optimal configuration</li> </ol> <p>Manual threshold mode is much faster.</p>"},{"location":"fifo_depth/#why-is-replay-modeled-with-cp-sat-if-the-result-is-just-bdp","title":"Why is replay modeled with CP-SAT if the result is just BDP?","text":"<p>Replay currently follows deterministically from:</p> <pre><code>peak_inflight = min(rtt, horizon - rtt) \u00d7 w_max\n</code></pre> <p>But CP-SAT is used for:</p> <ul> <li>consistency with other solvers</li> <li>reuse of infrastructure</li> <li>future support of jitter, retries, multi-sender cases</li> </ul> <p>BDP is just the simplest member of a larger family of replay behaviors.</p>"},{"location":"fifo_depth/#why-does-cdc-always-use-closed-form-math-instead-of-cp-sat","title":"Why does CDC always use closed-form math instead of CP-SAT?","text":"<p>CDC behavior is governed by:</p> <ul> <li>synchronizer latency</li> <li>Gray code pointer stability</li> <li>phase uncertainty</li> <li>PPM drift</li> </ul> <p>These have strict analytic bounds and no adversarial scheduling. Closed-form computation is exact and instantaneous.</p>"},{"location":"fifo_depth/#why-does-rounding-sometimes-jump-depth-by-a-large-factor","title":"Why does rounding sometimes jump depth by a large factor?","text":"<p>Two features cause this:</p> <ol> <li>Margin (percentage or absolute)</li> <li>Rounding (<code>power2</code>)</li> </ol> <p>Example:</p> <pre><code>depth_raw = 13\n25% margin \u2192 16.25 \u2192 17\nround to power of 2 \u2192 32\n</code></pre> <p>The tool prioritizes safety and hardware alignment.</p> <p>To avoid over-sizing:</p> <ul> <li>disable rounding</li> <li>or apply zero margin</li> <li>inspect raw depth first</li> <li>then manually choose rounding</li> </ul>"},{"location":"fifo_depth/#why-does-the-tool-warn-that-the-horizon-may-be-too-small","title":"Why does the tool warn that the horizon may be too small?","text":"<p>Because true peak occupancy might occur beyond the examined window.</p> <p>The heuristic check:</p> <pre><code>horizon &gt;= (sum_w_max / w_max) + (sum_r_max / r_max)\n</code></pre> <p>warns when the user-specified horizon may miss the true worst case.</p>"},{"location":"fifo_depth/#why-are-witness-traces-sometimes-non-intuitive","title":"Why are witness traces sometimes non-intuitive?","text":"<p>Because the solver:</p> <ol> <li>Builds deterministic worst-case valid masks</li> <li>Then schedules writes/reads adversarially within those masks</li> <li>Maximizes occupancy</li> </ol> <p>This leads to witness patterns that are mathematically valid but may not always follow expected patterns. The witness ensures correctness for the computed FIFO depth.</p>"},{"location":"fifo_depth/#appendix","title":"Appendix","text":""},{"location":"fifo_depth/#key-classes","title":"Key Classes","text":"Class Defined In Role <code>FifoSolver</code> <code>fifo_depth_base.py</code> Abstract base class for all solvers <code>FifoParams</code> <code>fifo_depth_base.py</code> Parameter model validated from YAML <code>FifoResults</code> <code>fifo_depth_base.py</code> Container for solver results <code>CdcSolver</code> <code>fifo_depth_cdc.py</code> CDC partition computation <code>CbfcSolver</code> <code>fifo_depth_cbfc.py</code> Credit-based FIFO solver"},{"location":"fifo_depth/#references","title":"References","text":"<ul> <li>Google OR-Tools CP-SAT Solver</li> </ul>"},{"location":"fifo_depth/#literature","title":"Literature","text":"<p>[1] W. Dally and B. Towles, Principles and Practices of Interconnection Networks. San Francisco, CA: Morgan Kaufmann, 2004.</p> <p>[2] A. DeJans Jr, The MILP Optimization Handbook: An Introduction to Linear and Integer Programming for Practitioners. Bit Bros LLC, 2025.</p> <p>[3] C. Soviani and S. A. Edwards, \"FIFO sizing for high-performance pipelines,\" in Proc. 16th Int. Workshop Logic Synth., San Diego, CA, 2007.</p> <p>[4] R. Lu and C. K. Koh, \"Performance optimization of latency insensitive systems through buffer queue sizing of communications channels,\" in Proc. Int. Conf. Comput. Aided Design, San Jose, CA, 2003.</p> <p>[5] \"Calculation of FIFO depth - made easy.\" Accessed: Nov. 23, 2025. [Online]. Available: https://hardwaregeeksblog.wordpress.com/wp-content/uploads/2016/12/fifodepthcalculationmadeeasy2.pdf</p> <p>[6] Chipressian, Crack the Hardware Interview - from RTL Designers' Perspective: Architecture and Micro-architecture. Middletown, DE: Chipressian Publishing, 2025.</p>"},{"location":"fifo_depth/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"formal/","title":"RAD Formal","text":""},{"location":"formal/#reusable-asic-designs-rad-formal","title":"Reusable ASIC Designs (RAD) \u2013 Formal","text":""},{"location":"formal/#overview","title":"Overview","text":"<p>The Reusable ASIC Designs (RAD) environment includes a formal verification flow built with open\u2011source tools. Formal verification works together with RAD's linting, synthesis, and DV flows. It uses math to prove that key safety properties are correct in each design.</p> <p>The RAD Design flow checks structure and synthesis. The RAD Formal flow checks logic for all possible input sequences.</p> <p>The RAD Formal methodology focuses on:</p> <ul> <li>Practical properties that match the implementation</li> <li>Small, focused proof harnesses</li> <li>Reusable SBY templates</li> <li>Repeatable Make\u2011based automation</li> </ul> <p>This document describes a flow that fits naturally after initial RTL and design\u2011side checks and before DV simulation.</p>"},{"location":"formal/#audience","title":"Audience","text":"<ul> <li>ASIC RTL designers adding formal checks to RAD IP</li> <li>Verification engineers using formal together with simulation</li> <li>Architects checking safety and corner\u2011case behavior</li> </ul>"},{"location":"formal/#purpose","title":"Purpose","text":"<ul> <li>Check that key safety properties work correctly for all legal inputs</li> <li>Find corner\u2011case bugs earlier than simulation</li> <li>Provide automated, repeatable proofs that work with Make</li> <li>Use the same structure for formal files across all RAD designs</li> </ul>"},{"location":"formal/#key-features","title":"Key Features","text":"<ul> <li>SymbiYosys\u2011based flow (<code>prove</code> and <code>cover</code>)</li> <li>Reusable SBY templates for each design</li> <li>Standard formal testbench structure</li> <li>Open\u2011source SMT solvers (Boolector recommended)</li> <li>Make\u2011based automation for proofs and coverage</li> <li>Same directory structure for each <code>rad_&lt;design&gt;</code> design</li> </ul>"},{"location":"formal/#getting-started","title":"Getting Started","text":""},{"location":"formal/#set-up-and-install-the-environment","title":"Set Up and Install the Environment","text":"<p>See ABE Python Development for Python environment setup details.</p> <pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"formal/#install-required-tools","title":"Install Required Tools","text":"<pre><code>make deps\n</code></pre> <p>This shows any missing tools. Installation steps depend on your platform and are not covered in this document.</p>"},{"location":"formal/#run-examples","title":"Run Examples","text":"<pre><code>make DESIGN=rad_async_fifo formal\nmake DESIGN=rad_async_fifo formal-cover\n</code></pre>"},{"location":"formal/#examine-outputs","title":"Examine Outputs","text":"<ul> <li><code>out_formal/&lt;design&gt;</code></li> <li><code>out_formal/&lt;design&gt;_cover</code></li> </ul>"},{"location":"formal/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>.\n\u251c\u2500\u2500 mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00-vars.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 10-helpers.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 20-python.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 50-formal.mk\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 rad\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_mem.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_rptr.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_sync.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_wptr.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 srclist.f\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 formal\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_cover.sby\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_async_fifo_formal_top.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rad_async_fifo.sby\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 shared\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_pulse_gen.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rad_timescale.svh\n\u251c\u2500\u2500 Makefile\n</code></pre>"},{"location":"formal/#makefiles","title":"Makefiles","text":"<p>Makefiles are in directory <code>mk</code>.</p> <ul> <li>Common flags come from <code>00-vars.mk</code>.</li> <li>Formal commands are in <code>50-formal.mk</code>.</li> </ul> <p>Common commands:</p> <pre><code>make formal-help\n</code></pre>"},{"location":"formal/#initial-steps","title":"Initial Steps","text":"<ol> <li>It's helpful to complete design\u2011side checks first:</li> <li><code>rtl-format</code></li> <li><code>rtl-lint-verible</code></li> <li><code>rtl-lint-verilator</code></li> <li><code>synth</code></li> <li>Create: <code>src/abe/rad/rad_&lt;design&gt;/formal</code></li> <li>Templates from proven designs like <code>rad_async_fifo</code> can serve as a starting point.</li> <li>Review existing formal collateral for examples.</li> </ol> <p>See also: Formal Verification Flow and Formal Coverage Flow.</p>"},{"location":"formal/#formal-verification-flow","title":"Formal Verification Flow","text":""},{"location":"formal/#formal-testbench-design_formal_topsv","title":"Formal Testbench: <code>&lt;design&gt;_formal_top.sv</code>","text":"<p>Main parts:</p> <ul> <li>Clock generation using <code>$global_clock</code> and <code>(* gclk *)</code> (see FAQ #6).</li> <li>Reset sequence for each domain.</li> <li><code>(* anyseq *)</code> for free inputs.</li> <li><code>assume</code> for legal input conditions (see FAQ #7).</li> <li><code>assert</code> for invariants and safety properties.</li> <li><code>$past()</code> protected by <code>past_valid</code>.</li> </ul> <p>Reference:</p> <pre><code>src/abe/rad/rad_async_fifo/formal/rad_async_fifo_formal_top.sv\n</code></pre> <p>See also: SymbiYosys Configuration.</p>"},{"location":"formal/#symbiyosys-configuration-designsby","title":"SymbiYosys Configuration: <code>&lt;design&gt;.sby</code>","text":"<p>Sections:</p> Section Purpose <code>[options]</code> Mode (<code>prove</code>), depth, multiclock <code>[engines]</code> Solver selection (see FAQ #4) <code>[script]</code> Yosys steps <code>[files]</code> RTL + formal top <p>Reference:</p> <pre><code>rad_async_fifo/formal/rad_async_fifo.sby\n</code></pre> <p>See also: Running Proofs and Formal Coverage Flow.</p>"},{"location":"formal/#running-proofs","title":"Running Proofs","text":"<pre><code>make DESIGN=&lt;design&gt; formal\n</code></pre> <p>Examine the Output Directory: <code>out_formal/&lt;design&gt;</code></p> File/Directory Description <code>PASS</code> Status marker file containing verification statistics and elapsed time <code>config.sby</code> Copy of the <code>.sby</code> configuration file used for this run <code>engine_0/</code> Engine-specific outputs including trace files (<code>.vcd</code>, <code>.yw</code>) for counterexamples <code>logfile.txt</code> Complete SymbiYosys log showing all steps, solver progress, and results <code>model/</code> Intermediate Yosys files including the SMT2 model and design elaboration logs <code>&lt;design&gt;.xml</code> JUnit-style XML report of verification results <code>src/</code> Copies of all source files used in verification for reproducibility (see FAQ #8) <code>status</code> Human-readable summary of verification status (basecase/induction results) <code>status.sqlite</code> SQLite database with detailed status information <p>See also: FAQ #2 and FAQ #3.</p>"},{"location":"formal/#formal-coverage-flow","title":"Formal Coverage Flow","text":"<p>Create the Coverage Configuration: <code>&lt;design&gt;_cover.sby</code></p> <p>The coverage <code>.sby</code> file is almost the same as the verification configuration. The main difference is in the <code>[options]</code> section: use <code>mode cover</code> instead of <code>mode prove</code> (see FAQ #5). Coverage mode finds traces that meet the <code>cover</code> statements in your formal testbench. This is useful for:</p> <ul> <li>Creating traces.</li> <li>Checking reachability.</li> <li>Finding over\u2011constrained assumptions.</li> </ul> <p>Run:</p> <pre><code>make DESIGN=&lt;design&gt; formal-cover\n</code></pre> <p>Reference:</p> <pre><code>src/abe/rad/rad_async_fifo/formal/rad_async_fifo_cover.sby\n</code></pre>"},{"location":"formal/#faq","title":"FAQ","text":""},{"location":"formal/#why-use-formal-if-simulation-passes","title":"Why use formal if simulation passes?","text":"<p>Formal checks all legal input sequences. It works together with simulation testing. It can help find:</p> <ul> <li>Underflow/overflow.</li> <li>Race conditions.</li> <li>Reset bugs.</li> <li>Multi\u2011clock hazards.</li> <li>Illegal input patterns.</li> </ul> <p>These issues are hard to find with only simulation.</p>"},{"location":"formal/#what-depth-should-i-use","title":"What depth should I use?","text":"<p>Here are some starting values:</p> <ul> <li>Small modules: 16\u201340</li> <li>FIFOs &amp; CDC logic: 40\u201380</li> <li>Handshakes: 20\u201350</li> </ul> <p>Increase the depth if induction does not work at first.</p>"},{"location":"formal/#why-doesnt-induction-work","title":"Why doesn't induction work?","text":"<p>Check these common causes:</p> <ul> <li>Reset not modeled correctly.</li> <li>Missing assumptions.</li> <li><code>$past()</code> guard missing.</li> <li>Real bug in the design.</li> <li>Long initialization sequences.</li> </ul> <p>Making assumptions simpler or stronger can often fix induction problems.</p>"},{"location":"formal/#which-solvers-should-i-use","title":"Which solvers should I use?","text":"<ul> <li>Boolector (recommended to start).</li> <li>Yices or Z3 can help if Boolector does not support something.</li> </ul>"},{"location":"formal/#difference-between-formal-and-formal-cover","title":"Difference between <code>formal</code> and <code>formal-cover</code>?","text":"Mode Meaning prove Property must hold always cover Scenario must be reachable"},{"location":"formal/#why-global_clock","title":"Why <code>$global_clock</code>?","text":"<p>It enables:</p> <ul> <li>Correct multi\u2011clock modeling.</li> <li>Correct SMT scheduling.</li> <li>No need for manual clock generation.</li> </ul>"},{"location":"formal/#how-many-assumptions-are-too-many","title":"How many assumptions are too many?","text":"<p>Here is a helpful guide:</p> <p>Use assumptions for legal inputs, not for internal design behavior.</p>"},{"location":"formal/#why-does-symbiyosys-copy-source-files","title":"Why does SymbiYosys copy source files?","text":"<p>To make results repeatable. Each run includes everything:</p> <ul> <li>RTL.</li> <li>formal tops.</li> <li>logs.</li> <li>SMT model.</li> </ul>"},{"location":"formal/#references","title":"References","text":"<ul> <li>SymbiYosys</li> <li>yosys-smtbmc</li> <li>Boolector</li> </ul>"},{"location":"formal/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"pkt_quantize/","title":"Packet Quantization Tool","text":""},{"location":"pkt_quantize/#packet-quantization-calculator","title":"Packet Quantization Calculator","text":"<p>The <code>pkt-quantize</code> tool calculates bandwidth and packet rate metrics for packet-based interfaces where packets are quantized to bus beats. Given bus width, clock frequency, and minimum processing cycles, it computes performance across a range of packet sizes and generates tables, CSV files, and plots. The tool assumes packets cannot share a bus beat (e.g., AXI-Stream). There are protocols like AMBA CXS that allow multiple packets per beat. Such protocols are not subject to the quantization effects modeled by this tool.</p>"},{"location":"pkt_quantize/#getting-started","title":"Getting Started","text":""},{"location":"pkt_quantize/#set-up-and-install-the-environment","title":"Set Up and Install the Environment","text":"<p>See ABE Python Development for Python environment setup details.</p> <pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"pkt_quantize/#run-examples","title":"Run Examples","text":"<pre><code>pkt-quantize\npkt-quantize --bus-width 64 --clk-freq 1.5e9 --min-cycles 2 --min-size 64\n--max-size 512\n</code></pre>"},{"location":"pkt_quantize/#examine-outputs","title":"Examine Outputs","text":"<pre><code>out_arch_pkt_quantize/*\n</code></pre>"},{"location":"pkt_quantize/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>\u251c\u2500\u2500 mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 80-uarch-pq.mk\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 uarch\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 pkt_quantize.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 utils.py\n</code></pre>"},{"location":"pkt_quantize/#command-line-options","title":"Command Line Options","text":"Option Description Default <code>--bus-width</code> Bus width (bytes) <code>128</code> <code>--clk-freq</code> Clock frequency (Hz) <code>1.1e9</code> <code>--min-cycles</code> Minimum clock cycles to process a packet <code>1</code> <code>--min-size</code> Minimum packet size (bytes) <code>64</code> <code>--max-size</code> Maximum packet size (bytes) <code>1518</code> <code>--outdir</code> Output directory <code>out_uarch_pkt_quantize/</code> <code>--no-plot-save</code> Skip saving plots to PNG Off <code>--no-plot-show</code> Skip displaying plots in GUI Off <code>--log-level</code> Logging level (<code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>) <code>info</code>"},{"location":"pkt_quantize/#outputs","title":"Outputs","text":"File Description <code>table_&lt;config&gt;_abbrev.txt</code> Abbreviated table of results (Markdown-style) <code>table_&lt;config&gt;_full.txt</code> Full table of results (Markdown-style) <code>table_&lt;config&gt;.csv</code> CSV-formatted results <code>plot_bw_&lt;config&gt;.png</code> Bandwidth vs packet size plot <code>plot_pps_&lt;config&gt;.png</code> PPS vs packet size plot"},{"location":"pkt_quantize/#import-as-a-library","title":"Import as a Library","text":"<p>You can import the <code>PktQuantize</code> class into another Python program.</p> <pre><code>from abe.uarch.pkt_quantize import PktQuantize\n\n# Create instance with custom parameters\npq = PktQuantize(\n    bus_width=64,\n    clk_freq=1.5e9,\n    min_cycles=2,\n    min_size=64,\n    max_size=512\n)\n\n# Run calculations\npq.calc()\n\n# Access results\nfor size, stats in pq.pkt.items():\n    print(f\"Size: {size}, BW: {stats.bw / 1e9:.3f} Gbps\")\n</code></pre>"},{"location":"pkt_quantize/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"python_dev/","title":"Python Development","text":""},{"location":"python_dev/#abe-python-development","title":"ABE Python Development","text":""},{"location":"python_dev/#overview","title":"Overview","text":"<p>ABE uses Python for microarchitecture tools (see FIFO Depth Tool and Packet Quantization Calculator) and RAD DV. This document describes the static analysis tools that help maintain code quality.</p> <p>Audience: ABE contributors</p> <p>Tools:</p> <ul> <li>isort - Organize imports</li> <li>black - Format code</li> <li>pylint - Lint for errors and style</li> <li>mypy - Type check</li> </ul>"},{"location":"python_dev/#getting-started","title":"Getting Started","text":""},{"location":"python_dev/#set-up-and-install-the-environment","title":"Set Up and Install the Environment","text":"<pre><code>make py-venv-all\nsource .venv/bin/activate\nmake py-install-all\n</code></pre>"},{"location":"python_dev/#run-example","title":"Run Example","text":"<pre><code>make PY_SRCS=ALL py-static-fix\n</code></pre> <p>See FAQ for more usage examples.</p>"},{"location":"python_dev/#examine-outputs","title":"Examine Outputs","text":"<p>Outputs appear at the console.</p>"},{"location":"python_dev/#explore-relevant-directory-layout","title":"Explore Relevant Directory Layout","text":"<pre><code>.\n\u251c\u2500\u2500 mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 00-vars.mk\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 20-python.mk\n\u251c\u2500\u2500 isort.cfg\n\u251c\u2500\u2500 mypy.ini\n\u251c\u2500\u2500 pyproject.toml\n</code></pre>"},{"location":"python_dev/#makefiles","title":"Makefiles","text":"<p>Makefiles are in directory <code>mk</code>. See Makefiles section for details.</p> <ul> <li>Common flags come from <code>00-vars.mk</code>.</li> <li>Python commands are in <code>20-python.mk</code>.</li> </ul> <p>Common commands:</p> <pre><code>make py-help\n</code></pre>"},{"location":"python_dev/#organize-imports-with-isort","title":"Organize Imports with isort","text":"<p>isort automatically sorts and organizes Python import statements. It groups imports into sections (standard library, third-party, local) and sorts them alphabetically for consistency.</p>"},{"location":"python_dev/#isort-commands","title":"isort Commands","text":"<p>Check import organization without modifying files:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-isort-check\n</code></pre> <p>Fix import organization:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-isort-fix\n</code></pre> <p>The format commands also include isort:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-format-check  # includes isort check\nmake PY_SRCS=&lt;files&gt; py-format-fix    # includes isort fix\n</code></pre>"},{"location":"python_dev/#isort-configuration","title":"isort Configuration","text":"<p>Configured in <code>.isort.cfg</code> and <code>pyproject.toml</code> under <code>[tool.isort]</code>.</p>"},{"location":"python_dev/#format-with-black","title":"Format with black","text":"<p>black is a Python code formatter that automatically formats code to a consistent style. It applies the same formatting rules everywhere, making code easier to read and review.</p>"},{"location":"python_dev/#black-commands","title":"black Commands","text":"<p>Check code formatting without modifying files:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-format-check\n</code></pre> <p>Fix code formatting:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-format-fix\n</code></pre>"},{"location":"python_dev/#black-configuration","title":"black Configuration","text":"<p>Configured in <code>pyproject.toml</code> under <code>[tool.black]</code>.</p>"},{"location":"python_dev/#lint-with-pylint","title":"Lint with pylint","text":"<p>pylint analyzes Python code for errors and style issues. It finds bugs and potential problems before you run the code.</p>"},{"location":"python_dev/#commands","title":"Commands","text":"<p>Run pylint on specified files:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-lint\n</code></pre>"},{"location":"python_dev/#configuration","title":"Configuration","text":"<p>Configured in <code>pyproject.toml</code> under <code>[tool.pylint]</code> and via command-line flags in <code>mk/00-vars.mk</code>.</p>"},{"location":"python_dev/#type-check-with-mypy","title":"Type Check with mypy","text":"<p>mypy is a static type checker for Python. It checks type annotations without running the code and finds type-related bugs early.</p>"},{"location":"python_dev/#mypy-commands","title":"mypy Commands","text":"<p>Run mypy type checking on specified files:</p> <pre><code>make PY_SRCS=&lt;files&gt; py-typecheck\n</code></pre>"},{"location":"python_dev/#mypy-configuration","title":"mypy Configuration","text":"<ul> <li>Configured in <code>mypy.ini</code>.</li> <li>The <code>typings</code> directory contains necessary type stubs for imports.</li> </ul>"},{"location":"python_dev/#faq","title":"FAQ","text":""},{"location":"python_dev/#why-doesnt-abe-use-the-latest-python-version","title":"Why doesn't ABE use the latest Python version?","text":"<p>ABE targets the latest Python version when dependencies support it.</p>"},{"location":"python_dev/#what-does-py_srcsall-mean","title":"What does <code>PY_SRCS=ALL</code> mean?","text":"<p><code>ALL</code> runs tools on all Python files in the workspace tracked by git.</p>"},{"location":"python_dev/#how-do-i-run-all-static-checks-at-once","title":"How do I run all static checks at once?","text":"<pre><code>make PY_SRCS=ALL py-static-check  # check only\nmake PY_SRCS=ALL py-static-fix    # check and fix\n</code></pre>"},{"location":"python_dev/#can-i-run-tools-on-specific-files","title":"Can I run tools on specific files?","text":"<p>Yes, set <code>PY_SRCS</code> to specific file patterns:</p> <pre><code>make PY_SRCS=\"src/abe/uarch/*.py\" py-lint\nmake PY_SRCS=\"src/abe/rad/tools/dv.py\" py-typecheck\n</code></pre>"},{"location":"python_dev/#references","title":"References","text":"<ul> <li>isort</li> <li>black</li> <li>pylint</li> <li>mypy</li> </ul>"},{"location":"python_dev/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"rad_async_fifo_dv_readme/","title":"RAD ASYNC FIFO DV Overview","text":""},{"location":"rad_async_fifo_dv_readme/#rad_async_fifo-dv-guide","title":"<code>rad_async_fifo</code> \u2014 DV Guide","text":""},{"location":"rad_async_fifo_dv_readme/#overview","title":"Overview","text":"<p>This verification environment implements a dual-agent architecture to properly model the independent write and read clock domains of the rad_async_fifo dual-clock asynchronous FIFO.</p>"},{"location":"rad_async_fifo_dv_readme/#design-rationale","title":"Design Rationale","text":"<p>The rad_async_fifo RTL has:</p> <ul> <li>Write domain: Operates on <code>wclk</code>, uses <code>wrst_n</code>, controls <code>winc</code> and <code>wdata</code>, observes <code>wfull</code></li> <li>Read domain: Operates on <code>rclk</code>, uses <code>rrst_n</code>, controls <code>rinc</code>, observes <code>rdata</code> and <code>rempty</code></li> </ul> <p>These domains are independent - in a real system, they would be controlled by separate blocks that only see their respective interface signals. This fundamental architectural constraint led to the dual-agent design.</p>"},{"location":"rad_async_fifo_dv_readme/#dual-agent-architecture","title":"Dual-Agent Architecture","text":""},{"location":"rad_async_fifo_dv_readme/#agent-0-write-domain","title":"Agent 0: Write Domain","text":"<ul> <li>Clock: <code>wclk</code> (default 1000ps period)</li> <li>Reset: <code>wrst_n</code></li> <li>Driver: <code>RadAsyncFifoWriteDriver</code> - Drives <code>winc</code>, <code>wdata</code> on <code>wclk</code> edges</li> <li>Monitors:<ul> <li><code>RadAsyncFifoWriteMonitorIn</code> - Samples <code>winc</code>, <code>wdata</code> on <code>wclk</code></li> <li><code>RadAsyncFifoWriteMonitorOut</code> - Samples <code>wfull</code> on <code>wclk</code></li> </ul> </li> <li>Item: <code>RadAsyncFifoWriteItem</code><ul> <li>Inputs: <code>winc</code>, <code>wdata</code></li> <li>Outputs: <code>wfull</code> (feedback from DUT)</li> </ul> </li> <li>Sequence: <code>RadAsyncFifoWriteSequence</code><ul> <li>Generates random write transactions with configurable probability (default 0.7)</li> <li>Protocol enforcement handled by driver, not sequence</li> <li>Generates random <code>wdata</code> values within configured data width</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#agent-1-read-domain","title":"Agent 1: Read Domain","text":"<ul> <li>Clock: <code>rclk</code> (default 1200ps period)</li> <li>Reset: <code>rrst_n</code></li> <li>Driver: <code>RadAsyncFifoReadDriver</code> - Drives <code>rinc</code> on <code>rclk</code> edges</li> <li>Monitors:<ul> <li><code>RadAsyncFifoReadMonitorIn</code> - Samples <code>rinc</code> on <code>rclk</code></li> <li><code>RadAsyncFifoReadMonitorOut</code> - Samples <code>rdata</code>, <code>rempty</code> on <code>rclk</code></li> </ul> </li> <li>Item: <code>RadAsyncFifoReadItem</code><ul> <li>Inputs: <code>rinc</code></li> <li>Outputs: <code>rdata</code>, <code>rempty</code> (feedback from DUT)</li> </ul> </li> <li>Sequence: <code>RadAsyncFifoReadSequence</code><ul> <li>Generates random read transactions with configurable probability (default 0.7)</li> <li>Protocol enforcement handled by driver, not sequence</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#component-structure","title":"Component Structure","text":"<pre><code>RadAsyncFifoEnv (num_agents=2)\n\u251c\u2500\u2500 agent0 (write domain)\n\u2502   \u251c\u2500\u2500 drv: RadAsyncFifoWriteDriver\n\u2502   \u251c\u2500\u2500 sqr: BaseSequencer[RadAsyncFifoWriteItem]\n\u2502   \u251c\u2500\u2500 mon_in: RadAsyncFifoWriteMonitorIn\n\u2502   \u2514\u2500\u2500 mon_out: RadAsyncFifoWriteMonitorOut\n\u251c\u2500\u2500 agent1 (read domain)\n\u2502   \u251c\u2500\u2500 drv: RadAsyncFifoReadDriver\n\u2502   \u251c\u2500\u2500 sqr: BaseSequencer[RadAsyncFifoReadItem]\n\u2502   \u251c\u2500\u2500 mon_in: RadAsyncFifoReadMonitorIn\n\u2502   \u2514\u2500\u2500 mon_out: RadAsyncFifoReadMonitorOut\n\u251c\u2500\u2500 mon_rst: BaseResetMonitor (wrst_n, configured but not used)\n\u251c\u2500\u2500 reset_sink: BaseResetSink (configured but not used)\n\u251c\u2500\u2500 mon_wrst: BaseResetMonitor (wrst_n) \u2192 wrst_sink\n\u251c\u2500\u2500 mon_rrst: BaseResetMonitor (rrst_n) \u2192 rrst_sink\n\u251c\u2500\u2500 wrst_sink: RadAsyncFifoResetSink \u2192 routes to ref_model.wrst_change()\n\u251c\u2500\u2500 rrst_sink: RadAsyncFifoResetSink \u2192 routes to ref_model.rrst_change()\n\u251c\u2500\u2500 sb: RadAsyncFifoSb\n\u2502   \u251c\u2500\u2500 prd: RadAsyncFifoSbPredictor[RadAsyncFifoRefModel]\n\u2502   \u2514\u2500\u2500 cmp: BaseSbComparator\n\u2514\u2500\u2500 cov: RadAsyncFifoCoverage\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#test-execution-flow","title":"Test Execution Flow","text":"<ol> <li>Clock Setup: Test creates independent <code>wclk_driver</code> and <code>rclk_driver</code></li> <li>Reset Setup: Test creates independent <code>wrst_driver</code> and <code>rrst_driver</code></li> <li>Factory Overrides: Instance-specific overrides for each agent</li> <li><code>*.agent0.*</code> \u2192 Write components</li> <li><code>*.agent1.*</code> \u2192 Read components</li> <li>Run Phase: Sequences run concurrently using <code>cocotb.start_soon()</code></li> </ol> <p>```python    write_task = cocotb.start_soon(write_seq.start(self.env.agents[0].sqr))    read_task = cocotb.start_soon(read_seq.start(self.env.agents[1].sqr))</p> <p>await write_task    await read_task    ```</p>"},{"location":"rad_async_fifo_dv_readme/#protocol-enforcement-backpressure","title":"Protocol Enforcement (Backpressure)","text":"<p>Backpressure is handled in the drivers, not the sequences. This separation allows:</p> <ul> <li>Sequences to focus on stimulus generation (probabilities, patterns)</li> <li>Drivers to enforce protocol correctness (respecting full/empty flags)</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#write-driver-backpressure","title":"Write Driver Backpressure","text":"<p>The write driver samples <code>wfull</code> at each drive edge and stalls if necessary:</p> <pre><code>while True:\n    await self.clock_drive_edge()  # Advance to negedge of wclk\n\n    wfull_now = utils_dv.get_signal_value_int(dut.wfull.value)\n\n    if tr.winc and wfull_now:\n        # Backpressure: FIFO is full, stall this write\n        dut.winc.value = 0\n        # Loop to next cycle and re-check wfull\n    else:\n        # Either no write requested, or FIFO is not full\n        dut.winc.value = tr.winc\n        dut.wdata.value = tr.wdata\n        break  # Exit after successful drive\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#read-driver-backpressure","title":"Read Driver Backpressure","text":"<p>The read driver samples <code>rempty</code> at each drive edge and stalls if necessary:</p> <pre><code>while True:\n    await self.clock_drive_edge()  # Advance to negedge of rclk\n\n    rempty_now = utils_dv.get_signal_value_int(dut.rempty.value)\n\n    if tr.rinc and rempty_now:\n        # Backpressure: FIFO is empty, stall this read\n        dut.rinc.value = 0\n        # Loop to next cycle and re-check rempty\n    else:\n        # Either no read requested, or FIFO is not empty\n        dut.rinc.value = tr.rinc\n        break  # Exit after successful drive\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#sequence-generation","title":"Sequence Generation","text":"<p>Sequences generate transactions based on probability, independent of FIFO state:</p> <pre><code># Write sequence\nitem.winc = 1 if random.random() &lt; self.write_prob else 0\nif item.winc:\n    item.wdata = random.randint(0, (1 &lt;&lt; self.dsize) - 1)\n\n# Read sequence\nitem.rinc = 1 if random.random() &lt; self.read_prob else 0\n</code></pre> <p>This design ensures protocol correctness while allowing flexible stimulus patterns.</p>"},{"location":"rad_async_fifo_dv_readme/#reset-handling","title":"Reset Handling","text":"<p>The environment supports independent reset domains with domain-specific routing:</p> <ul> <li>Write Reset Path: <code>mon_wrst</code> \u2192 <code>wrst_sink</code> \u2192 <code>ref_model.wrst_change()</code></li> <li>Read Reset Path: <code>mon_rrst</code> \u2192 <code>rrst_sink</code> \u2192 <code>ref_model.rrst_change()</code></li> </ul> <p>Each reset sink (<code>RadAsyncFifoResetSink</code>) routes reset events to:</p> <ol> <li>The corresponding driver (agent0.drv or agent1.drv) via <code>drv.reset_change()</code></li> <li>The reference model's domain-specific method (<code>wrst_change</code> or <code>rrst_change</code>)</li> </ol> <p>The reference model (<code>RadAsyncFifoRefModel</code>) implements:</p> <ul> <li><code>wrst_change(value, active)</code>: Clears write-domain state when active</li> <li><code>rrst_change(value, active)</code>: Clears read-domain state when active</li> <li><code>reset_change(value, active)</code>: Legacy single-reset method (clears both domains)</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"rad_async_fifo_dv_readme/#why-dual-agents","title":"Why Dual Agents?","text":"<p>Rejected alternatives:</p> <ol> <li>\u274c Single sequence controlling both domains - unrealistic, violates clock domain separation</li> <li>\u274c Dual sequences with single agent - complexity in driver/sequencer routing</li> <li>\u274c Single sequence with dual clock driver - doesn't model real system behavior</li> <li>\u2705 Dual agents - clean separation, matches real system architecture</li> </ol>"},{"location":"rad_async_fifo_dv_readme/#why-backpressure-in-drivers","title":"Why Backpressure in Drivers?","text":"<ul> <li>Protocol enforcement separate from stimulus generation</li> <li>Sequences focus on test patterns (random, burst, corner cases)</li> <li>Drivers ensure protocol correctness (never write when full, never read when empty)</li> <li>Allows reuse of driver logic across different sequence types</li> <li>Models real hardware behavior: protocol is enforced at interface level</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#why-cocotbstart_soon","title":"Why cocotb.start_soon?","text":"<ul> <li>Both sequences must run concurrently (not sequentially)</li> <li>Write and read operations happen simultaneously in different clock domains</li> <li><code>cocotb.start_soon()</code> is the cocotb-native way to launch concurrent tasks</li> <li>Unlike <code>asyncio.gather()</code>, it works properly with cocotb's scheduler</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#files","title":"Files","text":""},{"location":"rad_async_fifo_dv_readme/#transaction-items","title":"Transaction Items","text":"<ul> <li><code>rad_async_fifo_item.py</code> - Contains both transaction classes:<ul> <li><code>RadAsyncFifoWriteItem</code> - Write domain (winc, wdata, wfull)</li> <li><code>RadAsyncFifoReadItem</code> - Read domain (rinc, rdata, rempty)</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#drivers","title":"Drivers","text":"<ul> <li><code>rad_async_fifo_driver.py</code> - Contains both driver classes:<ul> <li><code>RadAsyncFifoWriteDriver</code> - Drives write inputs on wclk</li> <li><code>RadAsyncFifoReadDriver</code> - Drives read inputs on rclk</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#sequences","title":"Sequences","text":"<ul> <li><code>rad_async_fifo_sequence.py</code> - Contains both sequence classes:<ul> <li><code>RadAsyncFifoWriteSequence</code> - Generates write transactions</li> <li><code>RadAsyncFifoReadSequence</code> - Generates read transactions</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#monitors","title":"Monitors","text":"<ul> <li><code>rad_async_fifo_monitor_in.py</code> - Contains both input monitor classes:<ul> <li><code>RadAsyncFifoWriteMonitorIn</code> - Samples winc, wdata on wclk</li> <li><code>RadAsyncFifoReadMonitorIn</code> - Samples rinc on rclk</li> </ul> </li> <li><code>rad_async_fifo_monitor_out.py</code> - Contains both output monitor classes:<ul> <li><code>RadAsyncFifoWriteMonitorOut</code> - Samples wfull on wclk</li> <li><code>RadAsyncFifoReadMonitorOut</code> - Samples rdata, rempty on rclk</li> </ul> </li> </ul>"},{"location":"rad_async_fifo_dv_readme/#environment-test","title":"Environment &amp; Test","text":"<ul> <li><code>rad_async_fifo_env.py</code> - Environment with <code>num_agents=2</code> and dual reset monitors</li> <li><code>test_rad_async_fifo.py</code> - Test with dual clocks/resets/sequences</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#shared-components","title":"Shared Components","text":"<ul> <li><code>rad_async_fifo_ref_model.py</code> - Golden model with dual-reset support</li> <li><code>rad_async_fifo_coverage.py</code> - Functional coverage for both domains</li> <li><code>rad_async_fifo_reset_sink.py</code> - Reset event router with configurable method names</li> </ul>"},{"location":"rad_async_fifo_dv_readme/#configuration","title":"Configuration","text":""},{"location":"rad_async_fifo_dv_readme/#clock-configuration","title":"Clock Configuration","text":"<pre><code># Write clock (default 1000ps)\nWCLK_PERIOD_PS=1000 WCLK_ENABLE=1\n\n# Read clock (default 1200ps, shows async behavior)\nRCLK_PERIOD_PS=1200 RCLK_ENABLE=1\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#reset-configuration","title":"Reset Configuration","text":"<pre><code># Write reset\nWRST_ENABLE=1 WRST_ACTIVE_LOW=1 WRST_CYCLES=10\n\n# Read reset\nRRST_ENABLE=1 RRST_ACTIVE_LOW=1 RRST_CYCLES=10\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#sequence-configuration","title":"Sequence Configuration","text":"<pre><code># Write sequence length (number of transactions)\nRAD_ASYNC_FIFO_WRITE_SEQ_LEN=100\n\n# Read sequence length (number of transactions)\nRAD_ASYNC_FIFO_READ_SEQ_LEN=100\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#fifo-configuration","title":"FIFO Configuration","text":"<pre><code># Data width (default 8 bits)\nRAD_ASYNC_FIFO_DSIZE=8\n\n# Address width determines depth = 2^ASIZE (default 3 \u2192 depth=8)\nRAD_ASYNC_FIFO_ASIZE=3\n</code></pre>"},{"location":"rad_async_fifo_dv_readme/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements:</p> <ol> <li>Variable timing sequences: Add random delays between transactions</li> <li>Burst sequences: Write/read bursts until full/empty</li> <li>Stress sequences: Maximum rate writes and reads</li> <li>Corner case sequences: Single item, wrap-around, simultaneous full/empty</li> <li>Protocol violations: Intentionally violate timing constraints</li> <li>Coverage-driven: Use coverage feedback to guide sequence generation</li> </ol>"},{"location":"rad_async_fifo_dv_readme/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"rad_cdc_mcp_dv_readme/","title":"RAD CDC MCP DV Overview","text":""},{"location":"rad_cdc_mcp_dv_readme/#rad_cdc_mcp-dv-guide","title":"<code>rad_cdc_mcp</code> \u2014 DV Guide","text":""},{"location":"rad_cdc_mcp_dv_readme/#overview","title":"Overview","text":"<p>This verification environment implements a dual-agent architecture to properly model the independent source and destination clock domains of the rad_cdc_mcp dual-clock Multi-Cycle Path (MCP) synchronizer.</p>"},{"location":"rad_cdc_mcp_dv_readme/#design-rationale","title":"Design Rationale","text":"<p>The rad_cdc_mcp RTL has:</p> <ul> <li>a-domain (source): Operates on <code>aclk</code>, uses <code>arst_n</code>, controls <code>asend</code> and <code>adatain</code>, observes <code>aready</code></li> <li>b-domain (destination): Operates on <code>bclk</code>, uses <code>brst_n</code>, controls <code>bload</code>, observes <code>bdata</code> and <code>bvalid</code></li> </ul> <p>These domains are independent - in a real system, they would be controlled by separate blocks that only see their respective interface signals. This fundamental architectural constraint led to the dual-agent design.</p>"},{"location":"rad_cdc_mcp_dv_readme/#dual-agent-architecture","title":"Dual-Agent Architecture","text":""},{"location":"rad_cdc_mcp_dv_readme/#agent-0-a-domain-source","title":"Agent 0: a-domain (Source)","text":"<ul> <li>Clock: <code>aclk</code> (default 1000ps period)</li> <li>Reset: <code>arst_n</code></li> <li>Driver: <code>RadCdcMcpWriteDriver</code> - Drives <code>asend</code>, <code>adatain</code> on <code>aclk</code> edges</li> <li>Monitors:<ul> <li><code>RadCdcMcpWriteMonitorIn</code> - Samples <code>asend</code>, <code>adatain</code> on <code>aclk</code></li> <li><code>RadCdcMcpWriteMonitorOut</code> - Samples <code>aready</code> on <code>aclk</code></li> </ul> </li> <li>Item: <code>RadCdcMcpWriteItem</code><ul> <li>Inputs: <code>asend</code>, <code>adatain</code></li> <li>Outputs: <code>aready</code> (feedback from DUT)</li> </ul> </li> <li>Sequence: <code>RadCdcMcpWriteSequence</code><ul> <li>Generates random send transactions with configurable probability (default 0.7)</li> <li>Protocol enforcement handled by driver, not sequence</li> <li>Generates random <code>adatain</code> values within configured data width</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#agent-1-b-domain-destination","title":"Agent 1: b-domain (Destination)","text":"<ul> <li>Clock: <code>bclk</code> (default 1200ps period)</li> <li>Reset: <code>brst_n</code></li> <li>Driver: <code>RadCdcMcpReadDriver</code> - Drives <code>bload</code> on <code>bclk</code> edges</li> <li>Monitors:<ul> <li><code>RadCdcMcpReadMonitorIn</code> - Samples <code>bload</code> on <code>bclk</code></li> <li><code>RadCdcMcpReadMonitorOut</code> - Samples <code>bdata</code>, <code>bvalid</code> on <code>bclk</code></li> </ul> </li> <li>Item: <code>RadCdcMcpReadItem</code><ul> <li>Inputs: <code>bload</code></li> <li>Outputs: <code>bdata</code>, <code>bvalid</code> (feedback from DUT)</li> </ul> </li> <li>Sequence: <code>RadCdcMcpReadSequence</code><ul> <li>Generates random load transactions with configurable probability (default 0.7)</li> <li>Protocol enforcement not required (driver does not implement backpressure)</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#component-structure","title":"Component Structure","text":"<pre><code>RadCdcMcpEnv (num_agents=2)\n\u251c\u2500\u2500 agent0 (a-domain / source)\n\u2502   \u251c\u2500\u2500 drv: RadCdcMcpWriteDriver\n\u2502   \u251c\u2500\u2500 sqr: BaseSequencer[RadCdcMcpWriteItem]\n\u2502   \u251c\u2500\u2500 mon_in: RadCdcMcpWriteMonitorIn\n\u2502   \u2514\u2500\u2500 mon_out: RadCdcMcpWriteMonitorOut\n\u251c\u2500\u2500 agent1 (b-domain / destination)\n\u2502   \u251c\u2500\u2500 drv: RadCdcMcpReadDriver\n\u2502   \u251c\u2500\u2500 sqr: BaseSequencer[RadCdcMcpReadItem]\n\u2502   \u251c\u2500\u2500 mon_in: RadCdcMcpReadMonitorIn\n\u2502   \u2514\u2500\u2500 mon_out: RadCdcMcpReadMonitorOut\n\u251c\u2500\u2500 mon_rst: BaseResetMonitor (arst_n, configured but not used)\n\u251c\u2500\u2500 reset_sink: BaseResetSink (configured but not used)\n\u251c\u2500\u2500 mon_arst: BaseResetMonitor (arst_n) \u2192 arst_sink\n\u251c\u2500\u2500 mon_brst: BaseResetMonitor (brst_n) \u2192 brst_sink\n\u251c\u2500\u2500 arst_sink: RadCdcMcpResetSink \u2192 routes to ref_model.arst_change()\n\u251c\u2500\u2500 brst_sink: RadCdcMcpResetSink \u2192 routes to ref_model.brst_change()\n\u251c\u2500\u2500 sb: RadCdcMcpSb\n\u2502   \u251c\u2500\u2500 prd: RadCdcMcpSbPredictor[RadCdcMcpRefModel]\n\u2502   \u2514\u2500\u2500 cmp: BaseSbComparator\n\u2514\u2500\u2500 cov: RadCdcMcpCoverage\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#test-execution-flow","title":"Test Execution Flow","text":"<ol> <li>Clock Setup: Test creates independent <code>aclk_driver</code> and <code>bclk_driver</code></li> <li>Reset Setup: Test creates independent <code>arst_driver</code> and <code>brst_driver</code></li> <li>Factory Overrides: Instance-specific overrides for each agent</li> <li><code>*.agent0.*</code> \u2192 a-domain (source) components</li> <li><code>*.agent1.*</code> \u2192 b-domain (destination) components</li> <li>Run Phase: Sequences run concurrently using <code>cocotb.start_soon()</code></li> </ol> <p>```python    write_task = cocotb.start_soon(write_seq.start(self.env.agents[0].sqr))    read_task = cocotb.start_soon(read_seq.start(self.env.agents[1].sqr))</p> <p>await write_task    await read_task    ```</p>"},{"location":"rad_cdc_mcp_dv_readme/#protocol-enforcement-backpressure","title":"Protocol Enforcement (Backpressure)","text":"<p>Backpressure is handled in the drivers, not the sequences. This separation allows:</p> <ul> <li>Sequences to focus on stimulus generation (probabilities, patterns)</li> <li>Drivers to enforce protocol correctness (respecting ready/valid flags)</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#a-domain-driver-write-backpressure","title":"a-domain Driver (Write) Backpressure","text":"<p>The a-domain driver samples <code>aready</code> at each drive edge and stalls if necessary:</p> <pre><code>while True:\n    await self.clock_drive_edge()  # Advance to negedge of aclk\n\n    aready_now = utils_dv.get_signal_value_int(dut.aready.value)\n\n    if tr.asend and not aready_now:\n        # Backpressure: MCP is not ready, stall this send\n        dut.asend.value = 0\n        # Loop to next cycle and re-check aready\n    else:\n        # Either no send requested, or MCP is ready\n        dut.asend.value = tr.asend\n        dut.adatain.value = tr.adatain\n        break  # Exit after successful drive\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#b-domain-driver-read-no-backpressure","title":"b-domain Driver (Read) - No Backpressure","text":"<p>The b-domain driver does not implement backpressure logic:</p> <pre><code>await self.clock_drive_edge()  # Advance to negedge of bclk\n\ndut.bload.value = tr.bload\n# Can always drive bload regardless of bvalid state\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#sequence-generation","title":"Sequence Generation","text":"<p>Sequences generate transactions based on probability, independent of MCP state:</p> <pre><code># a-domain send sequence\nitem.asend = 1 if random.random() &lt; self.send_prob else 0\nif item.asend:\n    item.adatain = random.randint(0, (1 &lt;&lt; self.dsize) - 1)\n\n# b-domain load sequence\nitem.bload = 1 if random.random() &lt; self.load_prob else 0\n</code></pre> <p>This design ensures protocol correctness while allowing flexible stimulus patterns.</p>"},{"location":"rad_cdc_mcp_dv_readme/#reset-handling","title":"Reset Handling","text":"<p>The environment supports independent reset domains with domain-specific routing:</p> <ul> <li>a-domain Reset Path: <code>mon_arst</code> \u2192 <code>arst_sink</code> \u2192 <code>ref_model.arst_change()</code></li> <li>b-domain Reset Path: <code>mon_brst</code> \u2192 <code>brst_sink</code> \u2192 <code>ref_model.brst_change()</code></li> </ul> <p>Each reset sink (<code>RadCdcMcpResetSink</code>) routes reset events to:</p> <ol> <li>The corresponding driver (agent0.drv or agent1.drv) via <code>drv.reset_change()</code></li> <li>The reference model's domain-specific method (<code>arst_change</code> or <code>brst_change</code>)</li> </ol> <p>The reference model (<code>RadCdcMcpRefModel</code>) implements:</p> <ul> <li><code>arst_change(value, active)</code>: Clears a-domain state when active</li> <li><code>brst_change(value, active)</code>: Clears b-domain state when active</li> <li><code>reset_change(value, active)</code>: Legacy single-reset method (clears both domains)</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"rad_cdc_mcp_dv_readme/#why-dual-agents","title":"Why Dual Agents?","text":"<p>Rejected alternatives:</p> <ol> <li>\u274c Single sequence controlling both domains - unrealistic, violates clock domain separation</li> <li>\u274c Dual sequences with single agent - complexity in driver/sequencer routing</li> <li>\u274c Single sequence with dual clock driver - doesn't model real system behavior</li> <li>\u2705 Dual agents - clean separation, matches real system architecture</li> </ol>"},{"location":"rad_cdc_mcp_dv_readme/#why-backpressure-in-a-domain-driver-only","title":"Why Backpressure in a-domain Driver Only?","text":"<ul> <li>Protocol enforcement separate from stimulus generation</li> <li>a-domain (source) must respect <code>aready</code> to ensure MCP can accept data</li> <li>b-domain (destination) can assert <code>bload</code> freely; data validity is checked   via <code>bvalid</code></li> <li>Sequences focus on test patterns (random, burst, corner cases)</li> <li>Drivers ensure protocol correctness at the interface level</li> <li>Models real hardware behavior: protocol is enforced at interface level</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#why-cocotbstart_soon","title":"Why cocotb.start_soon?","text":"<ul> <li>Both sequences must run concurrently (not sequentially)</li> <li>Send and load operations happen simultaneously in different clock domains</li> <li><code>cocotb.start_soon()</code> is the cocotb-native way to launch concurrent tasks</li> <li>Unlike <code>asyncio.gather()</code>, it works properly with cocotb's scheduler</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#files","title":"Files","text":""},{"location":"rad_cdc_mcp_dv_readme/#transaction-items","title":"Transaction Items","text":"<ul> <li><code>rad_cdc_mcp_item.py</code> - Contains both transaction classes:<ul> <li><code>RadCdcMcpWriteItem</code> - a-domain (asend, adatain, aready)</li> <li><code>RadCdcMcpReadItem</code> - b-domain (bload, bdata, bvalid)</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#drivers","title":"Drivers","text":"<ul> <li><code>rad_cdc_mcp_driver.py</code> - Contains both driver classes:<ul> <li><code>RadCdcMcpWriteDriver</code> - Drives a-domain inputs on aclk with backpressure</li> <li><code>RadCdcMcpReadDriver</code> - Drives b-domain inputs on bclk (no backpressure)</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#sequences","title":"Sequences","text":"<ul> <li><code>rad_cdc_mcp_sequence.py</code> - Contains both sequence classes:<ul> <li><code>RadCdcMcpWriteSequence</code> - Generates send transactions</li> <li><code>RadCdcMcpReadSequence</code> - Generates load transactions</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#monitors","title":"Monitors","text":"<ul> <li><code>rad_cdc_mcp_monitor_in.py</code> - Contains both input monitor classes:<ul> <li><code>RadCdcMcpWriteMonitorIn</code> - Samples asend, adatain on aclk</li> <li><code>RadCdcMcpReadMonitorIn</code> - Samples bload on bclk</li> </ul> </li> <li><code>rad_cdc_mcp_monitor_out.py</code> - Contains both output monitor classes:<ul> <li><code>RadCdcMcpWriteMonitorOut</code> - Samples aready on aclk</li> <li><code>RadCdcMcpReadMonitorOut</code> - Samples bdata, bvalid on bclk</li> </ul> </li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#environment-test","title":"Environment &amp; Test","text":"<ul> <li><code>rad_cdc_mcp_env.py</code> - Environment with <code>num_agents=2</code> and dual reset monitors</li> <li><code>test_rad_cdc_mcp.py</code> - Test with dual clocks/resets/sequences</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#shared-components","title":"Shared Components","text":"<ul> <li><code>rad_cdc_mcp_ref_model.py</code> - Golden model with dual-reset support</li> <li><code>rad_cdc_mcp_coverage.py</code> - Functional coverage for both domains</li> <li><code>rad_cdc_mcp_reset_sink.py</code> - Reset event router with configurable method names</li> </ul>"},{"location":"rad_cdc_mcp_dv_readme/#configuration","title":"Configuration","text":""},{"location":"rad_cdc_mcp_dv_readme/#clock-configuration","title":"Clock Configuration","text":"<pre><code># a-domain clock (default 1000ps)\nACLK_PERIOD_PS=1000 ACLK_ENABLE=1\n\n# b-domain clock (default 1200ps, shows async behavior)\nBCLK_PERIOD_PS=1200 BCLK_ENABLE=1\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#reset-configuration","title":"Reset Configuration","text":"<pre><code># a-domain reset\nARST_ENABLE=1 ARST_ACTIVE_LOW=1 ARST_CYCLES=10\n\n# b-domain reset\nBRST_ENABLE=1 BRST_ACTIVE_LOW=1 BRST_CYCLES=10\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#sequence-configuration","title":"Sequence Configuration","text":"<pre><code># a-domain sequence length (number of send transactions)\nRAD_CDC_MCP_WRITE_SEQ_LEN=100\n\n# b-domain sequence length (number of load transactions)\nRAD_CDC_MCP_READ_SEQ_LEN=100\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#mcp-configuration","title":"MCP Configuration","text":"<pre><code># Data width (default 8 bits)\nRAD_CDC_MCP_DSIZE=8\n</code></pre>"},{"location":"rad_cdc_mcp_dv_readme/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements:</p> <ol> <li>Variable timing sequences: Add random delays between transactions</li> <li>Burst sequences: Send/load bursts with configurable patterns</li> <li>Stress sequences: Maximum rate sends and loads</li> <li>Corner case sequences: Single item, simultaneous send/load edge cases</li> <li>Protocol violations: Intentionally violate timing constraints</li> <li>Coverage-driven: Use coverage feedback to guide sequence generation</li> <li>Back-to-back operations: Test consecutive sends/loads without idle cycles</li> </ol>"},{"location":"rad_cdc_mcp_dv_readme/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"rad_cdc_sync_dv_readme/","title":"RAD CDC SYNC DV Overview","text":""},{"location":"rad_cdc_sync_dv_readme/#rad_cdc_sync-dv-guide","title":"<code>rad_cdc_sync</code> \u2014 DV Guide","text":""},{"location":"rad_cdc_sync_dv_readme/#overview","title":"Overview","text":"<p>This verification environment implements a single-agent architecture to verify the rad_cdc_sync multi-stage clock domain crossing synchronizer. The DUT is a simple pipeline of flip-flops that synchronizes an asynchronous input signal to the destination clock domain.</p>"},{"location":"rad_cdc_sync_dv_readme/#design-rationale","title":"Design Rationale","text":"<p>The rad_cdc_sync RTL has:</p> <ul> <li>Synchronous domain: Operates on <code>clk</code>, uses <code>rst_n</code>, observes <code>sync_o</code></li> <li>Asynchronous input: <code>async_i</code> can toggle at arbitrary times relative to <code>clk</code></li> <li>Parameterizable stages: <code>STAGES</code> (default 2) determines synchronizer depth</li> <li>Optional metastability simulation: When <code>SIMULATE_METASTABILITY</code> is defined, models metastability injection</li> </ul> <p>The DUT performs a single function: synchronizing an asynchronous signal into the clock domain. This straightforward architecture requires only a single agent to drive the async input and monitor the synchronized output.</p>"},{"location":"rad_cdc_sync_dv_readme/#single-agent-architecture","title":"Single-Agent Architecture","text":""},{"location":"rad_cdc_sync_dv_readme/#agent-0-synchronous-domain","title":"Agent 0: Synchronous Domain","text":"<ul> <li>Clock: <code>clk</code> (default 1000ps period)</li> <li>Reset: <code>rst_n</code></li> <li>Driver: <code>RadCdcSyncDriver</code> - Drives <code>async_i</code> with timing jitter relative to <code>clk</code> edges</li> <li>Monitors:<ul> <li><code>RadCdcSyncMonitorIn</code> - Samples <code>async_i</code> on <code>clk</code> (for reference model input)</li> <li><code>RadCdcSyncMonitorOut</code> - Samples <code>sync_o</code> on <code>clk</code> (synchronized output)</li> </ul> </li> <li>Item: <code>RadCdcSyncItem</code><ul> <li>Inputs: <code>async_i</code>, <code>delay_ps</code> (pre-toggle jitter)</li> <li>Outputs: <code>sync_o</code> (synchronized output from DUT)</li> </ul> </li> <li>Sequence: <code>RadCdcSyncSequence</code><ul> <li>Generates toggling pattern with timing jitter to stress metastability</li> <li>Enforces visible transitions (state alternates 0 \u2192 1 \u2192 0 \u2192 1)</li> <li>Applies random delay in \u00b120% window around half clock period</li> </ul> </li> </ul>"},{"location":"rad_cdc_sync_dv_readme/#component-structure","title":"Component Structure","text":"<pre><code>RadCdcSyncEnv (num_agents=1)\n\u251c\u2500\u2500 agent0 (synchronous domain)\n\u2502   \u251c\u2500\u2500 drv: RadCdcSyncDriver\n\u2502   \u251c\u2500\u2500 sqr: BaseSequencer[RadCdcSyncItem]\n\u2502   \u251c\u2500\u2500 mon_in: RadCdcSyncMonitorIn\n\u2502   \u2514\u2500\u2500 mon_out: RadCdcSyncMonitorOut\n\u251c\u2500\u2500 mon_rst: BaseResetMonitor (rst_n)\n\u251c\u2500\u2500 reset_sink: BaseResetSink \u2192 routes to ref_model.reset_change()\n\u251c\u2500\u2500 sb: RadCdcSyncSb\n\u2502   \u251c\u2500\u2500 prd: RadCdcSyncSbPredictor[RadCdcSyncRefModel]\n\u2502   \u2514\u2500\u2500 cmp: BaseSbComparator\n\u2514\u2500\u2500 cov: RadCdcSyncCoverage\n</code></pre>"},{"location":"rad_cdc_sync_dv_readme/#test-execution-flow","title":"Test Execution Flow","text":"<ol> <li>Clock Setup: Test creates single <code>clk_driver</code></li> <li>Reset Setup: Test creates single <code>rst_driver</code></li> <li>Factory Overrides: Type-level overrides for all components</li> <li>Run Phase: Single sequence runs on agent0.sqr</li> </ol> <p><code>python    seq = RadCdcSyncSequence.create()    await seq.start(self.env.agents[0].sqr)</code></p>"},{"location":"rad_cdc_sync_dv_readme/#timing-and-jitter","title":"Timing and Jitter","text":"<p>The verification strategy focuses on stressing the synchronizer's metastability handling by varying the timing relationship between <code>async_i</code> transitions and the <code>clk</code> edge.</p>"},{"location":"rad_cdc_sync_dv_readme/#driver-timing-strategy","title":"Driver Timing Strategy","text":"<p>The driver applies each transaction with configurable jitter:</p> <pre><code>async def drive_item(self, dut: Any, tr: RadCdcSyncItem) -&gt; None:\n    await self.clock_drive_edge()  # Align to clock edge\n    await Timer(tr.delay_ps, unit=\"ps\")  # Apply jitter\n    dut.async_i.value = tr.async_i  # Toggle the async input\n</code></pre>"},{"location":"rad_cdc_sync_dv_readme/#sequence-jitter-generation","title":"Sequence Jitter Generation","text":"<p>The sequence generates jitter within \u00b120% of the clock period around the half-period point:</p> <pre><code># For 1000ps clock: setup=400ps, hold=600ps\n# Jitter range: 400ps to 600ps after drive edge\nt = self.clock_period_ps\nwin = t // 5  # 20% window\nsetup = (t // 2) - win  # Half period minus window\nhold = (t // 2) + win   # Half period plus window\nitem.delay_ps = random.randrange(setup, hold)\n</code></pre> <p>This creates transitions that occur near the sampling edge of the destination clock, maximizing the likelihood of metastability in RTL simulations with metastability modeling enabled.</p>"},{"location":"rad_cdc_sync_dv_readme/#toggle-enforcement","title":"Toggle Enforcement","text":"<p>To ensure observable behavior, the sequence enforces alternating values:</p> <pre><code>self._state ^= 1  # Toggle internal state\nitem.async_i = self._state  # Always produces visible transitions\n</code></pre> <p>This prevents repeated same-value \"toggles\" that would be invisible to the synchronizer.</p>"},{"location":"rad_cdc_sync_dv_readme/#reference-model","title":"Reference Model","text":"<p>The <code>RadCdcSyncRefModel</code> implements a shift register matching the RTL's synchronizer chain:</p> <ul> <li>Configuration: Reads <code>RAD_CDC_STAGES</code> (default 2) and <code>RAD_CDC_VAL_ON_RESET</code> (default 0)</li> <li>Internal state: <code>_shreg</code> - deque of length <code>STAGES</code> representing the synchronizer pipeline</li> <li>Operation:</li> <li>On each input transaction, shift <code>async_i</code> into the front of the deque</li> <li>The last element of the deque represents the synchronized output</li> <li>During reset, all stages are initialized to <code>val_on_reset</code></li> </ul> <pre><code>def calc_exp(self, tr: RadCdcSyncItem) -&gt; RadCdcSyncItem:\n    if self._reset_active:\n        tr.sync_o = self.val_on_reset\n        return tr\n    async_i = int(tr.async_i or 0)\n    self._shreg.appendleft(async_i)  # Shift in new value\n    tr.sync_o = self._shreg[-1]      # Output is last stage\n    return tr\n</code></pre>"},{"location":"rad_cdc_sync_dv_readme/#reset-handling","title":"Reset Handling","text":"<p>The environment supports single-domain reset with standard routing:</p> <ul> <li>Reset Path: <code>mon_rst</code> \u2192 <code>reset_sink</code> \u2192 <code>ref_model.reset_change()</code></li> </ul> <p>The reset sink routes reset events to:</p> <ol> <li>The driver via <code>drv.reset_change()</code> to handle drive-edge waiting</li> <li>The reference model to clear internal state</li> </ol>"},{"location":"rad_cdc_sync_dv_readme/#metastability-simulation","title":"Metastability Simulation","text":"<p>When the RTL is compiled with <code>SIMULATE_METASTABILITY</code> defined:</p> <ul> <li>The DUT can inject metastable values (X) on setup/hold violations</li> <li>The injection window is configurable via <code>rad_cdc_meta_cfg_pkg</code></li> <li>Random seed control: <code>+RAD_CDC_RAND_SEED=&lt;value&gt;</code></li> <li>Injection messages: Controlled by <code>PRINT_INJECTION_MESSAGES</code> parameter</li> </ul> <p>The testbench handles metastability:</p> <ul> <li>Reference model ignores X values (treats as previous stable value)</li> <li>Comparator waits for resolution before checking</li> <li>Coverage tracks metastability events when enabled</li> </ul>"},{"location":"rad_cdc_sync_dv_readme/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"rad_cdc_sync_dv_readme/#why-single-agent","title":"Why Single Agent?","text":"<p>The rad_cdc_sync DUT has no clock domain crossing in the traditional multi-clock sense:</p> <ul> <li>Only one clock domain (<code>clk</code>) drives the synchronous logic</li> <li>The <code>async_i</code> input is truly asynchronous (no associated clock)</li> <li>No protocol or handshaking between domains</li> <li>Simple pipeline structure</li> </ul> <p>Therefore:</p> <ul> <li>\u2705 Single agent - matches the single synchronous clock domain</li> <li>\u274c Dual agents would be unnecessary complexity for this simple DUT</li> </ul>"},{"location":"rad_cdc_sync_dv_readme/#why-timing-jitter","title":"Why Timing Jitter?","text":"<p>The critical verification challenge for synchronizers is metastability:</p> <ul> <li>Transitions near the clock edge can cause metastable states</li> <li>Varying the timing relationship stresses the synchronizer</li> <li>Jitter creates setup/hold violations when metastability simulation is enabled</li> <li>Deterministic timing patterns would miss corner cases</li> </ul>"},{"location":"rad_cdc_sync_dv_readme/#why-toggle-enforcement","title":"Why Toggle Enforcement?","text":"<p>Observable verification requires visible signal changes:</p> <ul> <li>Random values might accidentally repeat (e.g., 1 \u2192 1)</li> <li>Repeated values don't propagate through the synchronizer</li> <li>Alternating pattern guarantees every transaction creates observable behavior</li> <li>Simplifies debug and coverage analysis</li> </ul>"},{"location":"rad_cdc_sync_dv_readme/#configuration","title":"Configuration","text":"<p>Configure via environment variables or plusargs:</p> <pre><code># Synchronizer stages (must be &gt;= 2)\n+RAD_CDC_STAGES=3\n\n# Reset value for all stages\n+RAD_CDC_VAL_ON_RESET=1\n\n# Sequence length\n+RAD_CDC_SYNC_SEQ_LEN=200\n\n# Random seed (for metastability injection when enabled)\n+RAD_CDC_RAND_SEED=42\n</code></pre>"},{"location":"rad_cdc_sync_dv_readme/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"rad_new_design/","title":"Creating a New RAD Design","text":""},{"location":"rad_new_design/#creating-a-new-rad-design","title":"Creating a New RAD Design","text":""},{"location":"rad_new_design/#overview","title":"Overview","text":"<p>This document describes how to create a new reusable IP design in the RAD (Reusable ASIC Designs) environment. It brings together information from these documents:</p> <ul> <li>FIFO Depth Tool &amp; Packet Quantization Calculator \u2014 tools for sizing buffers and analyzing throughput</li> <li>ABE Python Development \u2014 Python coding standards for DV utilities</li> <li>RAD Design \u2014 RTL structure, linting, formatting, synthesis</li> <li>RAD Formal \u2014 formal proof setup and methods</li> <li>RAD DV \u2014 UVM-style testbench using cocotb + pyuvm</li> </ul> <p>A RAD design includes RTL, formal verification, DV tests, and documentation. All parts follow ABE conventions and use Make-based flows.</p> <p>This guide provides a step-by-step process for creating a new RAD design.</p>"},{"location":"rad_new_design/#goals","title":"Goals","text":"<p>A complete RAD design should:</p> <ul> <li>Use a consistent directory and naming structure</li> <li>Pass static checks (formatting, linting, synthesis)</li> <li>Include formal proofs of key safety properties</li> <li>Include a complete UVM-style DV testbench that runs with open-source simulators</li> <li>Include documentation that explains purpose and usage</li> <li>Work with ABE's Make-based automation</li> </ul> <p>RAD helps make this process repeatable, predictable, and high-quality.</p>"},{"location":"rad_new_design/#directory-structure","title":"Directory Structure","text":"<p>RAD designs follow a consistent structure:</p> <pre><code>\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 abe\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 rad\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_&lt;design&gt;\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 dv_regress.yaml\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_&lt;design&gt;*.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test_rad_&lt;design&gt;.py\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 formal\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_&lt;design&gt;_cover.sby\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_&lt;design&gt;_formal_top.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 rad_&lt;design&gt;.sby\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rtl\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 rad_&lt;design&gt;*.sv\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 srclist.f\n</code></pre> <p>This structure ensures compatibility with all Makeflows, DV tools, and templates in the ABE environment.</p>"},{"location":"rad_new_design/#workflow","title":"Workflow","text":""},{"location":"rad_new_design/#1-create-the-design-directory","title":"1. Create the Design Directory","text":"<p>Create the top-level directory:</p> <pre><code>src/abe/rad/rad_&lt;design&gt;/\n</code></pre> <p>Add these subdirectories:</p> <pre><code>rtl/\nformal/\ndv/\n</code></pre> <p>Add a placeholder <code>README.md</code>.</p>"},{"location":"rad_new_design/#2-use-microarchitecture-tools-if-needed","title":"2. Use Microarchitecture Tools if Needed","text":"<p>If your design needs buffer sizing or throughput analysis, use the <code>fifo-depth</code> or <code>pkt-quantize</code> tools.</p>"},{"location":"rad_new_design/#3-write-rtl-using-rad-conventions","title":"3. Write RTL Using RAD Conventions","text":"<p>See RAD Design for RTL guidelines. Your RTL should:</p> <ul> <li>Include shared headers</li> <li>Have a <code>srclist.f</code> file</li> <li>Pass linting and synthesis checks</li> </ul>"},{"location":"rad_new_design/#4-add-formal-verification","title":"4. Add Formal Verification","text":"<p>You can use templates from existing designs as a starting point. Add:</p> <ul> <li>Safety properties</li> <li>Assumptions (on inputs only)</li> </ul> <p>Then run:</p> <pre><code>make DESIGN=rad_&lt;design&gt; formal\nmake DESIGN=rad_&lt;design&gt; formal-cover\n</code></pre>"},{"location":"rad_new_design/#5-create-the-dv-environment","title":"5. Create the DV Environment","text":"<ul> <li>Start with a template from an existing design.</li> <li>Customize these parts for your design:<ul> <li>Driver</li> <li>Monitors</li> <li>Item</li> <li>Reference model</li> <li>Sequence</li> <li>Coverage</li> <li>Tests</li> </ul> </li> <li>Run tests and regressions to verify your design works correctly.</li> </ul>"},{"location":"rad_new_design/#6-document-the-design","title":"6. Document the Design","text":"<p>Create a README.md that explains:</p> <ul> <li>What the design does</li> <li>The design's interface</li> <li>How the design behaves</li> <li>Any important assumptions</li> </ul>"},{"location":"rad_new_design/#checklist","title":"Checklist","text":"<p>\u2714 RTL is clean \u2714 Formal proofs pass \u2714 DV regression passes \u2714 Documentation is complete \u2714 Make commands work</p>"},{"location":"rad_new_design/#explore","title":"Explore","text":"<p>For more information, see:</p> <ul> <li>RAD Design</li> <li>RAD Formal</li> <li>RAD DV</li> </ul>"},{"location":"rad_new_design/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"},{"location":"rad_template_dv_readme/","title":"RAD DV Template","text":""},{"location":"rad_template_dv_readme/#rad_template-dv-guide","title":"<code>rad_template</code> \u2014 DV Guide","text":""},{"location":"rad_template_dv_readme/#licensing","title":"Licensing","text":"<p>See the <code>LICENSES</code> directory at the repository root.</p>"}]}